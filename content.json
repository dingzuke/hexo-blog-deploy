{"meta":{"title":"Ding Zuke's blog","subtitle":"个人博客","description":"一个web开发者的爬坑路","author":"丁祖科","url":"https://www.ding51.cn"},"pages":[{"title":"","date":"2020-05-22T09:00:23.407Z","updated":"2020-05-22T09:00:23.407Z","comments":true,"path":"google5d9a7416b18345fe.html","permalink":"https://www.ding51.cn/google5d9a7416b18345fe.html","excerpt":"","text":"google-site-verification: google5d9a7416b18345fe.html"},{"title":"about","date":"2018-11-13T02:55:06.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"about/index.html","permalink":"https://www.ding51.cn/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-14T06:06:53.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"categories/index.html","permalink":"https://www.ding51.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-14T06:07:40.000Z","updated":"2020-05-22T09:00:23.424Z","comments":true,"path":"tags/index.html","permalink":"https://www.ding51.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"ubuntu系统Nginx、Docker等安装","slug":"liunx常见指令、Nginx、Docker等","date":"2021-08-30T07:35:14.000Z","updated":"2021-08-30T08:49:27.220Z","comments":true,"path":"liunx-chang-jian-zhi-ling-nginx-docker-deng.html","link":"","permalink":"https://www.ding51.cn/liunx-chang-jian-zhi-ling-nginx-docker-deng.html","excerpt":"","text":"Nginx 安装及使用// 安装 sudo apt update sudo apt install nginx nginx -v // 相关命令 service nginx start service nginx stop service nginx restart sudo systemctl restart nginx nginx.conf 文件，路径为：/etc/nginx/nginx.conf default 服务主机配置文件，路径为：/etc/nginx/sites-available/default 默认页面 /var/www/html 常见的web服务配置: worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; gzip_vary on; gzip_comp_level 6; gzip_buffers 16 8k; gzip_min_length 1000; gzip_proxied any; gzip_disable \"msie6\"; #gzip_http_version 1.0; gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript; server { #error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } listen 80; server_name localhost; location ~ .*\\.(css|js|swf|html|htm|pdf)$ { root /var/www/html; autoindex on; index index.html index.htm; } location / { charset utf-8; root /var/www/html; index index.html index.htm; try_files $uri /index.html; } } } docker 安装 安装 Docker 参考https://www.cnblogs.com/gaofangye/p/12812486.html $ sudo apt-get update $ sudo apt-get install apt-transport-https ca-certificates curl software-properties-common $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add - $ sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu $(lsb_release -cs) stable\" $ sudo apt-get update $ sudo apt-get install docker-ce $ sudo usermod -a -G docker $USER # 如遇网络错误，请多试几次 安装 Docker-compose $ sudo su $ curl -L https://get.daocloud.io/docker/compose/releases/download/1.25.0/docker-compose-`uname -s`-`uname -m` > /usr/local/bin/docker-compose $ chmod +x /usr/local/bin/docker-compose //阿里云加速度 sudo mkdir -p /etc/docker sudo tee /etc/docker/daemon.json &lt;&lt;-'EOF' { \"registry-mirrors\": [\"https://m0jhwyr4.mirror.aliyuncs.com\"] } EOF sudo systemctl daemon-reload sudo systemctl restart docker 安装portainer 查找镜像： docker search portainer 下载镜像： docker pull portainer/portainer 启动：docker run -d -p 9000:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --name prtainer portainer/portainer 访问9000端口，管理docker镜像 常用的docker 命令 见文章 node 安装1.//如果安装nodejs 9.x版本 curl -sL https://deb.nodesource.com/setup_9.x | sudo -E bash - sudo apt-get install -y nodejs Jenkins 安装sudo apt-get install openjdk-8-jdk wget -q -O - https://pkg.jenkins.io/debian/jenkins-ci.org.key | sudo apt-key add - echo deb http://pkg.jenkins.io/debian-stable binary/ | sudo tee /etc/apt/sources.list.d/jenkins.list sudo apt-get update sudo apt-get install jenkins // 启动 停止 重启 service jenkins start service jenkins restart service jenkins stop 默认8080","categories":[],"tags":[]},{"title":"TypeScript 高级类型","slug":"TypeScript-高级类型入门","date":"2021-08-26T08:48:00.000Z","updated":"2021-08-30T02:38:23.680Z","comments":true,"path":"typescript-gao-ji-lei-xing-ru-men.html","link":"","permalink":"https://www.ding51.cn/typescript-gao-ji-lei-xing-ru-men.html","excerpt":"","text":"本文将介绍 交叉类型 联合类型 泛型&lt;T&gt; Partial Required Readonly Pick Omit 映射类型 1、交叉类型交叉类型是将多个类型合并为一个类型。把多种类型叠加到一起成为一种类型。PersonA &amp; PersonB &amp; PersonC。 type LeftType = { id: number; left: string; }; type RightType = { id: number; right: string; }; type IntersectionType = LeftType &amp; RightType; function showType(args: IntersectionType) { console.log(args); } showType({ id: 1, left: 'test', right: 'test' }); // Output: {id: 1, left: \"test\", right: \"test\"} 2、联合类型联合类型表示一个值可以是几种类型之一。 number | string | boolean type UnionType = string | number; function showType(arg: UnionType) { console.log(arg); } showType('test'); // Output: test showType(7); // Output: 7 注：如果一个值是联合类型，我们只能访问此联合类型的所有类型里共有的成员 interface Bird { fly(); layEggs(); } interface Fish { swim(); layEggs(); } function getSmallPet(): Fish | Bird { // ... } let pet = getSmallPet(); pet.layEggs(); // okay pet.swim(); // errors 我们不能确定一个 Bird | Fish类型的变量是否有fly方法。 如果变量在运行时是 Fish类型，那么调用pet.fly()就出错了 3、泛型&lt;T&gt;可以使用泛型来创建可重用的组件，一个组件可以支持多种类型的数据。组件不仅能够支持当前的数据类型，同时也能支持未来的数据类型。 如何创建泛型类型:需要使用&lt;&gt; 并将 T(名称可自定义)作为参数传递。 泛型接口 interface GenericType&lt;T> { id: number; name: T; } function showType(args: GenericType&lt;string>) { console.log(args); } showType({ id: 1, name: 'test' }); // Output: {id: 1, name: \"test\"} function showTypeTwo(args: GenericType&lt;number>) { console.log(args); } showTypeTwo({ id: 1, name: 4 }); // Output: {id: 1, name: 4} 多参数的泛型 interface GenericType&lt;T, U> { id: T; name: U; } function showType(args: GenericType&lt;number, string>) { console.log(args); } showType({ id: 1, name: 'test' }); // Output: {id: 1, name: \"test\"} function showTypeTwo(args: GenericType&lt;string, string[]>) { console.log(args); } showTypeTwo({ id: '001', name: ['This', 'is', 'a', 'Test'] }); // Output: {id: \"001\", name: Array[\"This\", \"is\", \"a\", \"Test\"]} 4、PartialPartial 允许你将T类型的所有属性设为可选,它将在每一个字段后面添加一个?。 interface PartialType { id: number; firstName: string; lastName: string; } function showType(args: Partial&lt;PartialType>) { console.log(args); } /* Partial&lt;PartialType> 等效于 interface PartialType { id?: number firstName?: string lastName?: string } */ showType({ id: 1 }); // Output: {id: 1} 5、Required将某个类型里的属性全部变为必选项 Required interface RequiredType { id: number; firstName?: string; lastName?: string; } function showType(args: Required&lt;RequiredType>) { console.log(args); } showType({ id: 1 }); // Error: Type '{ id: number: }' is missing the following properties from type 'Required&lt;RequiredType>': firstName, lastName 6、Readonly会转换类型的所有属性，以使它们无法被修改 Readonly interface ReadonlyType { id: number; name: string; } function showType(args: Readonly&lt;ReadonlyType>) { args.id = 4; console.log(args); } showType({ id: 1, name: 'Doe' }); // Error: Cannot assign to 'id' because it is a read-only property. 7、Pick此方法允许你从一个已存在的类型 T中选择一些属性作为K, 从而创建一个新类型。 Pick&lt;T, K&gt; interface PickType { id: number; firstName: string; lastName: string; } function showType(args: Pick&lt;PickType, 'firstName' | 'lastName'>) { console.log(args); } showType({ firstName: 'John', lastName: 'Doe' }); // Output: {firstName: \"John\"} showType({ id: 3 }); // Error: Object literal may only specify known properties, and 'id' does not exist in type 'Pick&lt;PickType, \"firstName\" | \"lastName\">' 8、OmitOmit的作用与Pick类型正好相反。不是选择元素，而是从类型T中删除K个属性。 Omit&lt;T, K&gt; interface PickType { id: number; firstName: string; lastName: string; } function showType(args: Omit&lt;PickType, 'firstName' | 'lastName'>) { console.log(args); } showType({ id: 7 }); // Output: {id: 7} showType({ firstName: 'John' }); // Error: Object literal may only specify known properties, and 'firstName' does not exist in type 'Pick&lt;PickType, \"id\">' 9、映射类型映射类型允许你从一个旧的类型，生成一个新的类型。 请注意，前面介绍的某些高级类型也是映射类型。如: /* Readonly， Partial和 Pick是同态的，但 Record不是。 因为 Record并不需要输入类型来拷贝属性，所以它不属于同态： */ type Readonly&lt;T> = { readonly [P in keyof T]: T[P]; }; type Partial&lt;T> = { [P in keyof T]?: T[P]; }; type Pick&lt;T, K extends keyof T> = { [P in K]: T[P]; }; type StringMap&lt;T> = { [P in keyof T]: string; }; function showType(arg: StringMap&lt;{ id: number; name: string }>) { console.log(arg); } showType({ id: 1, name: 'Test' }); // Error: Type 'number' is not assignable to type 'string'. showType({ id: 'testId', name: 'This is a Test' }); // Output: {id: \"testId\", name: \"This is a Test\"}","categories":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://www.ding51.cn/categories/TypeScript/"}],"tags":[{"name":"TypeScript","slug":"TypeScript","permalink":"https://www.ding51.cn/tags/TypeScript/"}]},{"title":"Object.assign()是深拷贝还是潜拷贝","slug":"Object-assign-是深拷贝还是潜拷贝","date":"2021-02-22T05:46:00.000Z","updated":"2021-08-18T07:52:18.587Z","comments":true,"path":"object-assign-shi-shen-kao-bei-huan-shi-qian-kao-bei.html","link":"","permalink":"https://www.ding51.cn/object-assign-shi-shen-kao-bei-huan-shi-qian-kao-bei.html","excerpt":"","text":"定义Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象分配到目标对象。它将返回目标对象。🌰 var obj = {}; var o1 = { a: 1, b: 1 }; var o2 = { b: 2 }; var obj = Object.assign(obj, o1, o2); console.log(obj); // { a: 1, b: 2 } 注意：如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性 深拷贝还是潜拷贝? 对象的浅拷贝：浅拷贝是对象共用的一个内存地址，对象的变化相互印象。 对象的深拷贝：简单理解深拷贝是将对象放到新的内存中，两个对象的改变不会相互影响。 举例一 var obj1 = {name: 'd'} var obj2 = {age: 23} Object.assign(obj1,obj2) obj2.age = 29 console.log(obj1) // {name: \"d\", age: 23} 上面可看出修改了obj2 的值并没有修改到目标对象，看起来是深拷贝 举例二 var obj1 = {name: 'd'} var obj2 = {age: {year: 2019}} Object.assign(obj1,obj2) obj2.age.year = 2020 console.log(obj1) // {name: \"d\", age: {year: 2020}} 修改了obj2 的值,同时也修改到目标对象，看起来是潜拷贝 总结：对于Object.assign()而言，如果对象的属性值为简单类型（string，number），通过Object.assign({},srcobj);得到的新对象为深拷贝；如果属性值为对象或其他引用类型，那对于这个对象而言其实是浅拷贝的，这是Object.assign()特别需要注意的地方。 手写深拷贝： function clone(target) { if (typeof target === 'object') { let cloneTarget = Array.isArray(target) ? [] : {}; for (const key in target) { cloneTarget[key] = clone(target[key]); } return cloneTarget; } else { return target; } };","categories":[{"name":"深拷贝","slug":"深拷贝","permalink":"https://www.ding51.cn/categories/深拷贝/"}],"tags":[{"name":"深拷贝","slug":"深拷贝","permalink":"https://www.ding51.cn/tags/深拷贝/"},{"name":"浅拷贝","slug":"浅拷贝","permalink":"https://www.ding51.cn/tags/浅拷贝/"}]},{"title":"BFC和IFC","slug":"BFC","date":"2021-02-18T05:25:00.000Z","updated":"2021-02-18T06:21:09.359Z","comments":true,"path":"bfc.html","link":"","permalink":"https://www.ding51.cn/bfc.html","excerpt":"","text":"BFC概念BFC 即 Block Formatting Contexts (块级格式化上下文)，具有 BFC 特性的元素可以看作是隔离了的独立容器，容器里面的元素不会在布局上影响到外面的元素。可以把 BFC 理解为一个封闭的大箱子，箱子内部的元素无论如何翻江倒海，都不会影响到外部。 触发bfc只要元素满足下面任一条件即可触发 BFC 特性： body 根元素 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed) display 为 inline-block、table-cells、flex overflow 除了 visible 以外的值 (hidden、auto、scroll) 特性特性1、 同一个 BFC 上下margin会重叠,取最大的margin值。 解决方法: 利用bfc特性，让其元素 添加一层div, 设置为overflow: hidden; 使它形成一块独立的bfc. 特性2、 BFC可以包含浮动元素。 浮动元素会脱离文档流，父元素没有高度，造成父高度塌陷。 父元素设置成BFC 可以解决 特性3、BFC的区域不会与浮动容器发生重叠如图给右元素添加overflow: hidden;形成BFC。 谈谈IFCIFC（inline Formatting Context）叫做“行级格式化上下”局规则如下：1.内部的盒子会在水平方向，一个个地放置；2.IFC的高度，由里面最高盒子的高度决定；3.当一行不够放置的时候会自动切换到下一行","categories":[],"tags":[{"name":"BFC","slug":"BFC","permalink":"https://www.ding51.cn/tags/BFC/"},{"name":"IFC","slug":"IFC","permalink":"https://www.ding51.cn/tags/IFC/"}]},{"title":"js浏览器全屏模式","slug":"js浏览器全屏模式","date":"2020-12-16T09:37:00.000Z","updated":"2020-12-16T09:40:48.486Z","comments":true,"path":"js-liu-lan-qi-quan-ping-mo-shi.html","link":"","permalink":"https://www.ding51.cn/js-liu-lan-qi-quan-ping-mo-shi.html","excerpt":"","text":"1、进入全屏let docElm = document.documentElement; //W3C if(docElm.requestFullscreen) { docElm.requestFullscreen(); } //FireFox else if(docElm.mozRequestFullScreen) { docElm.mozRequestFullScreen(); } //Chrome等 else if(docElm.webkitRequestFullScreen) { docElm.webkitRequestFullScreen(); } //IE11 else if(elem.msRequestFullscreen) { elem.msRequestFullscreen(); } 2、退出全屏//W3C if (document.exitFullscreen) { document.exitFullscreen(); } //FireFox else if (document.mozCancelFullScreen) { document.mozCancelFullScreen(); } //Chrome等 else if (document.webkitCancelFullScreen) { document.webkitCancelFullScreen(); } //IE11 else if (document.msExitFullscreen) { document.msExitFullscreen(); }","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"全屏","slug":"全屏","permalink":"https://www.ding51.cn/tags/全屏/"}]},{"title":"迭代器(Iterator)和生成器(Generator)","slug":"迭代器-Iterator-和生成器-Generator","date":"2020-12-07T03:32:00.000Z","updated":"2020-12-07T05:48:42.590Z","comments":true,"path":"die-dai-qi-iterator-he-sheng-cheng-qi-generator.html","link":"","permalink":"https://www.ding51.cn/die-dai-qi-iterator-he-sheng-cheng-qi-generator.html","excerpt":"","text":"一、迭代器概念： 迭代器是一个统一的接口，它的作用是使各种数据结构可被便捷的访问，它是通过一个键为Symbol.iterator 的方法来实现。 迭代器是用于遍历数据结构元素的指针（如数据库中的游标）。 实现过程： 通过 Symbol.iterator 创建一个迭代器，指向当前数据结构的起始位置 随后通过 next 方法进行向下迭代指向下一个位置， next 方法会返回当前位置的对象，对象包含了 value 和 done 两个属性， value 是当前属性的值， done 用于判断是否遍历结束 当 done 为 true 时则遍历结束 let items = [\"zero\", \"one\", \"two\"]; let it = items[Symbol.iterator](); it.next(); // {value: \"zero\", done: false} it.next(); // {value: \"one\", done: false} it.next(); // {value: \"two\", done: false} it.next(); // {value: undefined, done: true} 可迭代的数据结构： Array String Map Set for…offor…of是 ES6 新引入的循环，用于替代 for..in 和 forEach() ，并且支持新的迭代协议。它可用于迭代常规的数据类型，如 Array 、 String 、 Map 和 Set 等等。 二、生成器概念生成器是一种返回迭代器的函数，通过function关键字后的星号(*)来表示，函数中会用到新的关键字yield。星号可以紧挨着function关键字，也可以在中间添加一个空格。区别普通函数 一是在 function 后面，函数名之前有个 * ； 函数内部有 yield 表达式。// 生成器 function *createIterator() { yield 1; yield 2; yield 3; } // 生成器能像正规函数那样被调用，但会返回一个迭代器 let iterator = createIterator(); console.log(iterator.next().value); // 1 console.log(iterator.next().value); // 2 console.log(iterator.next().value); // 3","categories":[{"name":"ES6","slug":"ES6","permalink":"https://www.ding51.cn/categories/ES6/"}],"tags":[{"name":"迭代器Iterator","slug":"迭代器Iterator","permalink":"https://www.ding51.cn/tags/迭代器Iterator/"},{"name":"生成器Generator","slug":"生成器Generator","permalink":"https://www.ding51.cn/tags/生成器Generator/"}]},{"title":"JavaScript常用设计模式","slug":"JavaScript常用设计模式","date":"2020-12-01T07:53:17.000Z","updated":"2020-12-03T09:40:37.478Z","comments":true,"path":"javascript-chang-yong-she-ji-mo-shi.html","link":"","permalink":"https://www.ding51.cn/javascript-chang-yong-she-ji-mo-shi.html","excerpt":"","text":"设计模式主要分为3类：1、创建型设计模式：专注于处理对象的创建Constructor构造器模式，Factory工厂模式，Singleton单例模式，builder生成器模式 2、结构型设计模式：对象间组合，建立对象之间的关系Decorator装饰者模式，Facade外观模式，Flyweight享元模式，Adapter适配器模式，Proxy代理模式 3、行为设计模式：简化和改善对象间的通信Mediator中介者模式，Observer观察者模式 一、 单例模式单例模式限制一个类只有一个实例化对象。 // 利用闭包实现 var Leader = (()=>{ let _instance = null; // 待实例化的类 function _module(){ this.name = ''; this.getName = ()=>{ return 'The Name Is ' + this.name; } this.setName = (name) => { this.name = name; } } return { getInstance:()=>{ if(!_instance){ _instance = new _module(); } return _instance; } } })(); Leader.getInstance().setName('dzk') Leader.getInstance().getName() 二、观察者模式一个目标对象维持着一系列依赖于它的对象，将有关状态的任何变更自动通知观察者们。在观察者模式中，观察者需要直接订阅目标对象，观察者与目标对象之间有一定的依赖关系。 // 目标对象 class Subject { constructor() { // 观察者列表 this.observers = [] } addObserver(observer) { this.observers.push(observer) } removeObserver() { this.observers.pop() } notify() { this.observers.forEach(observer => { observer.update() }) } } // 观察者1 class Observer1 { update() { console.log('Observer1 change!') } } // 观察者2 class Observer2 { update() { console.log('Observer2 change!') } } // 订阅 let curSubject = new Subject() let curObserver1 = new Observer1() let curObserver2 = new Observer2() curSubject.addObserver(curObserver1) curSubject.addObserver(curObserver2) // 触发 curSubject.notify() 三、发布/订阅模式发布订阅模式可以说是观察这模式的一种变体，一种实现。它使用一个主题/事件通道，介于发布者和订阅者之间，避免了发布者和订阅者之间的依赖关系。 class PubSub { constructor() { // 主题/事件通道 this.topics = {} } publish(topic, args) { if (!this.topics[topic]) { return } let subscribers = this.topics[topic] subscribers.forEach(subscriber => { subscriber(args) }) } subscribe(topic, subscriber ) { if (!this.topics[topic]) { this.topics[topic] = [] } this.topics[topic].push(subscriber ) } } // 接收函数1 let subscriber1 = (reData) => { console.log('subscriber1', reData) } // 接收函数2 let subscriber2 = (reData) => { console.log('subscriber2', reData) } let pubsub = new PubSub() pubsub.subscribe('reEvent', subscriber1 ) pubsub.subscribe('reEvent', subscriber2 ) pubsub.publish('reEvent', '通知了') 四、工厂模式工厂函数提供一个通用的接口来创建对象，我们可以指定我们希望创建的对象类型，我们通知工厂函数需要什么类型的对象并提供对应的数据，返回对应的实例。 class Car { constructor(options) { // ... } } class Truck { constructor(options) { // ... } } function vehicleFactory (options) { if (options.type === 'car') { return new Car(options) } else { return new Truck(options) } } let getInstance = vehicleFactory({type: 'car',name: 'xxx'}) 五、抽象工厂模式抽象工厂模式，将对象的实现细节抽离出来。适用于需要和多种对象一起工作的场景。 class Car { constructor(options) { // ... } } class Truck { constructor(options) { // ... } } class AbstractFactory { constructor() { this.types = {} } registerFactory(type, factory) { this.types[type] = factory } getInstance(type, args) { let factory = this.types[type] if (factory) { return new factory(args) } } } let abstractFactory = new AbortController() abstractFactory.registerFactory('car', Car) abstractFactory.registerFactory('truck', Truck) abstractFactory.getInstance('car', options) abstractFactory.getInstance('truck', options)","categories":[],"tags":[]},{"title":"盒子模型，行内元素边距，置换元素","slug":"盒子模型，行内元素边距，置换元素","date":"2020-09-09T03:29:00.000Z","updated":"2020-09-09T03:36:09.247Z","comments":true,"path":"he-zi-mo-xing-xing-nei-yuan-su-bian-ju-zhi-huan-yuan-su.html","link":"","permalink":"https://www.ding51.cn/he-zi-mo-xing-xing-nei-yuan-su-bian-ju-zhi-huan-yuan-su.html","excerpt":"","text":"一、 盒子模型 box-sizing: content-box;//宽度和高度分别应用到元素的内容框。在宽度和高度之外绘制元素的内边距和边框。 box-sizing: border-box;// 怪异盒子模型。 为元素设定的宽度和高度决定了元素的边框盒。元素指定的任何内边距和边框都将在已设定的宽度和高度内进行绘制。通过从已设定的宽度和高度分别减去边框和内边距才能得到内容的宽度和高度。 二、行内元素（如：span、em） 具有盒子模型。 设置宽高不起左右。 padding 内边距上下左右都有效果，但是上下是效果显示，不会产生实际的作用，不影响其他元素。左右会产生实际距离。 margin 只有左右产生效果影响，上下不会产生任何效果作用。 三、 置换元素置换元素：指浏览器是根据元素的属性来判断具体要显示的内容的元素。比如img标签，浏览器是根据其src的属性值来读取这个元素所包含的内容的，常见的替换元素还有 input、textarea、select、object、iframe和video等等 img虽然是行内元素，但是它是置换元素，他的padding 和 margin 都会产生实际作用。","categories":[{"name":"css","slug":"css","permalink":"https://www.ding51.cn/categories/css/"}],"tags":[]},{"title":"new 的实现过程  es5 es6类的对比","slug":"new-的实现过程-es5-es6类的对比","date":"2020-08-18T07:43:00.000Z","updated":"2020-08-19T03:31:51.034Z","comments":true,"path":"new-de-shi-xian-guo-cheng-es5-es6-lei-de-dui-bi.html","link":"","permalink":"https://www.ding51.cn/new-de-shi-xian-guo-cheng-es5-es6-lei-de-dui-bi.html","excerpt":"","text":"1、 手写new的实现过程主要实现步骤： 生成一个新对象 为这个对象设置prototype 使用this执行构造函数 返回这个对象 function _new() { // 1.生成一个新对象 let obj= {}; // 第一个参数是构造函数 let [Fn, ...args] = [...arguments]; // 2.为这个对象设置prototype;实际上就是生产了一个新的上下文 obj.__proto__ = Fn.prototype; // 3.使用apply在obj作用域中调用构造器函数，属性和方法被添加到 this 引用的对象即obj中 let result = Fn.apply(obj, args); if (result &amp;&amp; (typeof (result) == \"object\" || typeof (result) == \"function\")) { // 如果构造函数执行的结果返回的是一个对象，那么返回这个对象 return result; } // 4.如果构造函数返回的不是一个对象，返回创建的新对象 return obj; } var person1=_new(Person, 20) // 相当于 var person1 = new Person(20); 2、es5和es6中类的对比静态、私有变量等， 定义实现的对比 es5function Point(){ // 私有变量 var num = 10; // 定义获取私有变量的方法 在原型上不能直接获取私有变量 this.getNum = function(){ return num; } // public this.x = x; //x，y定义在对象自身上面 this.y = y; } Point.prototype.add = function(){ console.log(this.x + this.y); console.log(this.getNum()); // 获取私有变量 这里this.num直接获取不了 使用闭包返回数据 } //静态属性 Person.total = 0; //静态方法 Point.counter = function(){ return 'staticFn'; } var p = new Point(2, 3); p.add(); //输出5 1 0 es6class Point{ constructor(x, y) { //相当于java中的构造函数，如果不写默认为空 // public this.x = x; //x，y定义在对象自身上面 this.y = y; } // 私有属性 es2020 #num = 10; //静态属性 static total = 0; //静态方法 static counter(){ return 'staticFn'; } add() { //该方法定义在Point.prototype上 console.log(this.x + this.y); // 访问私有属性 console.log(this.#num); } } var p = new Point(2, 3); p.add(); //输出5 10 3、ES6中当函数用new关键词的时候，增加了new.target属性来判断当前调用的构造函数1、可以限制函数的调用，比如一定要用new命令来调用 function Person(name){ if(new.target === Person){ this.name = name; } else{ throw new Error('必须用new生成实例'); } } 2、限制类的调用方法，判断new.target是不是未定义。写出只能被继承使用的类。 class Shape { constructor() { if (new.target === Shape) { throw new Error('本类不能实例化'); } } } class Rectangle extends Shape { constructor(length, width) { super(); // ... } } var x = new Shape(); // 报错 var y = new Rectangle(3, 4); // 正确","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"new实现","slug":"new实现","permalink":"https://www.ding51.cn/tags/new实现/"},{"name":"es5类","slug":"es5类","permalink":"https://www.ding51.cn/tags/es5类/"},{"name":"es6类","slug":"es6类","permalink":"https://www.ding51.cn/tags/es6类/"}]},{"title":"this 和 构造函数有return ","slug":"this指向-和-构造函数有return","date":"2020-08-11T03:31:00.000Z","updated":"2020-08-11T03:42:59.807Z","comments":true,"path":"this-zhi-xiang-he-gou-zao-han-shu-you-return.html","link":"","permalink":"https://www.ding51.cn/this-zhi-xiang-he-gou-zao-han-shu-you-return.html","excerpt":"","text":"一、 es5中 this 1.在普通函数中的this总是代表他的直接调用者，默认情况下指向windos 2.在严格模式下，没有直接调用者的函数中的this是undefined使用 3.call,apply,bind，this指向的是绑定的对象； 4.构造函数中的this 二、 es6 箭头函数中 this箭头函数中的this指向是固定不变的，指向的是定义它的环境，最近的作用域。 1、点击事件绑定的this指向 &lt;body> &lt;button class=\"draw\" id=\"draw\">Draw&lt;/button> &lt;div onclick=\"func(this)\" name=\"book1\">click div&lt;/div> &lt;script> function func(_this) { console.log(_this); // 当前点击的div console.log(this); // window } var drawDom = document.getElementById('draw'); drawDom.addEventListener('click',function(){ console.log(this) // 当前div }) drawDom.addEventListener('click',() => { console.log(this) // window }) &lt;/script> &lt;/body> 2、嵌套函数 和变量不同，关键字this没有作用域的限制，嵌套的函数不会从调用它的函数中继承this。 1、如果嵌套函数作为方法调用，其this的值指向调用它的对象。 2、如果嵌套函数作为函数调用，其this值不是全局对象（非严格模式下）就是undefined（严格模式下）。 很多人误以为调用嵌套函数时this会指向调用外层函数的上下文。如果你想访问这个外部函数的this值，需要将this的值保存在一个变量里，这个变量和内部函数都在同一个作用域内。通常用self来保存this。 ——《犀牛书》8.2 函数调用 举例说明 var name = \"windName\" var data = { name:' d a taNam e', fn: function (){ var name = \"fnName\" console.log(this .name ) //输出：dataName this指向data var fn2 = () =>{ var name = \"fn2Name\" console.log(this.name) //输出：dataName } var fn3 = function(){ var name = \"fn3Name\" console.log(this.name) //输出：windName } fn2(); fn3(); // ** 嵌套的函数调用 this指向window(非严格模式) } } data.fn(); // 作为方法调用 输出： dataName dataName windName var a = { foo: 1, bar: () => console.log(this.foo)//这里是箭头函数指向 定义该箭头函数的作用域 } a.bar() //undefined this指向的window 三、 当函数构造函数有return时候 1.return的是五种简单数据类型：String，Numbe r ，Boolean，Null，Undefined。 这种情况下，忽视return值，依然返回this对象。 2.return的是Object 引用类型。 这种情况下，不再返回this对象，而是返回return语句的返回值 // 正常情况 function A(){ this.age = 12; } var a = new A(); a.age // 12 //举例 function A(){ this.age = 12; return {} } var a = new A(); a.age // undefined return返回的是引用类型。返回的是 {} //举例 function A(){ this.age = 12; return {age: 99} } var a = new A(); a.age //输出： 99 return返回的是引用类型。返回的是 {age: 99} //举例 function A(){ this.age = 12; return 13 } var a = new A(); a.age // 输出：12 return 12 返回的数值类型，返回this的对象","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"this","slug":"this","permalink":"https://www.ding51.cn/tags/this/"},{"name":"构造函数return ","slug":"构造函数return","permalink":"https://www.ding51.cn/tags/构造函数return/"}]},{"title":"原型题-解析","slug":"原型链题-解析","date":"2020-08-06T01:59:00.000Z","updated":"2020-08-06T02:09:09.862Z","comments":true,"path":"yuan-xing-lian-ti-jie-xi.html","link":"","permalink":"https://www.ding51.cn/yuan-xing-lian-ti-jie-xi.html","excerpt":"","text":"题目如下： function Fun(){ var getName = function(){ console.log(1); } return this; } Fun.getName = function(){ console.log(2); } Fun.prototype.getName = function(){ console.log(3); } var getName = function(){ console.log(4); } function getName(){ console.log(5); } Fun().getName(); getName(); Fun(); new Fun().getName(); new new Fun().getName(); 结果： Fun().getName(); // 4 getName(); // 4 Fun(); // 无输出 返回Window对象 new Fun().getName(); // 3 new new Fun().getName(); // 3 首先明白变量和函数提升， 函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。 // 举例说明 变量和函数提升（懂的自动跳过） a() function a() { console.log(1) } var a = function(){ console.log(2) } a() // 输出： 1 ， 2 // 执行的代码顺序如下 function a() { console.log(1) }; var a; a() // 输出 1 a = function(){ console.log(2) } a() // 输出2 详细解析：题目中变量提升后的写法（方便李姐） // getName 变量提升 function getName(){ console.log(5); } function Fun(){ var getName = function(){ console.log(1); } return this; } var getName; // 属性上添加getName Fun.getName = function(){ console.log(2); } // 原型上添加方法 Fun.prototype.getName = function(){ console.log(3); } getName = function(){ console.log(4); } Fun().getName(); getName(); Fun(); new Fun().getName(); new new Fun().getName() 1. Fun().getName()首先执行Fun()时，返回this,这里指向window，相当于 window.getName() , getName最后被 console.log(4) 的函数赋值； 所以输出： 4; 2.getName()相当于执行 window.getName()， 同上。 输出：4； 3.Fun()返回this, 当前环境 window 4.new Fun().getName()这里的执行顺序是 1.先 new Fun() 2.再执行getName() // 相当于执行 var fn = new Fun() fn.getName() 执行new Fun() 实例化的对象 后 ， getName()方法实会去 Fun构造函数中找，没找到然后会去原型 prototype上去找getName。这里原型链有该函数，调用 // 搞清楚 如下 function A(){ this.names = \"ab\" } A.names = \"kk\" A.prototype.names = \"99\" var a = new A() console.log(a.names) // ab console.log(A.names) // kk 5.new new Fun().getName()执行顺序： 1. new Fun() 2. new Fun.prototype.getName() // 相当于执行 var Fn1 = new Fun() var Fn2 = Fn1.getName new Fn2()","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"原型 ","slug":"原型","permalink":"https://www.ding51.cn/tags/原型/"},{"name":"变量提升","slug":"变量提升","permalink":"https://www.ding51.cn/tags/变量提升/"},{"name":"函数提升","slug":"函数提升","permalink":"https://www.ding51.cn/tags/函数提升/"}]},{"title":"回流 重绘","slug":"回流-重绘","date":"2020-07-22T06:29:00.000Z","updated":"2020-07-22T07:55:03.320Z","comments":true,"path":"hui-liu-chong-hui.html","link":"","permalink":"https://www.ding51.cn/hui-liu-chong-hui.html","excerpt":"","text":"一、概念 dom-tree: 浏览器把获取到的HTML代码解析成1个DOM树，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。 样式结构体: 浏览器把所有样式(用户定义的CSS和用户代理)解析。 render tree（渲染树）: dom-tree + 样式结构体, render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。 回流：当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的 例子： 添加或者删除可见的DOM元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 重绘：render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如字体color。则就叫称为重绘。 二、回流重绘区别： 至少会发生一次回流。 回流必将引起重绘，而重绘不一定会引起回流。 三、优化可以发现回流的成本要比重绘的成本高，与构建的render-tree 节点有关系。 浏览器优化浏览器自建一个队列，当回流和重绘达到一定数量或时间时，浏览器再更新。 代码层优化1. 添加dom节点时，创建个模板，一次添加完，不要一个个单独添加。2.分离读写 样式集中修改（浏览器优化机制），集中读取offsetWidth等属性（如果浏览器队列中回流等，每次读取这些属性都会引起回流），建议通过改变class或者csstext属性集中改变样式。 // 会引起四次 回流 div.style.left = '10px'; console.log(div.offsetLeft); div.style.top = '10px'; console.log(div.offsetTop); div.style.width = '20px'; console.log(div.offsetWidth); div.style.height = '20px'; console.log(div.offsetHeight); // 一次回流(前面4个样式的设置，浏览器会优化一次渲染) div.style.left = '10px'; div.style.top = '10px'; div.style.width = '20px'; div.style.height = '20px'; console.log(div.offsetLeft); console.log(div.offsetTop); console.log(div.offsetWidth); console.log(div.offsetHeight); // 推荐使用 class 和 cssText 改变 el.className += \" theclassname\"; el.style.cssText += \"; left: \" + left + \"px; top: \" + top + \"px;\"; 3.缓存布局信息// bad 强制刷新 触发两次重排 div.style.left = div.offsetLeft + 1 + 'px'; div.style.top = div.offsetTop + 1 + 'px'; // good 缓存布局信息 相当于读写分离 var curLeft = div.offsetLeft; var curTop = div.offsetTop; div.style.left = curLeft + 1 + 'px'; div.style.top = curTop + 1 + 'px'; 4.隐藏dom,再修改样式dom.display = 'none' // 修改dom样式，修改完再显示dom dom.display = 'block'","categories":[],"tags":[{"name":"重绘","slug":"重绘","permalink":"https://www.ding51.cn/tags/重绘/"},{"name":"回流","slug":"回流","permalink":"https://www.ding51.cn/tags/回流/"}]},{"title":"http缓存","slug":"http缓存","date":"2020-07-22T03:27:00.000Z","updated":"2020-07-22T03:30:44.805Z","comments":true,"path":"http-huan-cun.html","link":"","permalink":"https://www.ding51.cn/http-huan-cun.html","excerpt":"","text":"一、3种强缓存描述： 不需要发送请求到服务端，直接读取浏览器本地缓存 1. Expires（最低优先级）Expires 的值是一个 HTTP 日期，WEB服务器使用Expires头来告诉Web客户端，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。 Expires 的优先级在三个 Header 属性中是最低的。 2. Cache-Control（中）max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效 no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜 no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源 private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应 public：响应可以被中间代理、CDN 等缓存 must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证 3. Pragma（最高）Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致 二、协商缓存当浏览器的强缓存无效，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。 1. ETag（返回头） If-None-Match（请求头设置）ETag/If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。 2. Last-Modified（返回头） If-Modified-Since（请求头设置） Last-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。","categories":[{"name":"http","slug":"http","permalink":"https://www.ding51.cn/categories/http/"}],"tags":[{"name":"http缓存","slug":"http缓存","permalink":"https://www.ding51.cn/tags/http缓存/"}]},{"title":"柯里化-偏函数-反柯里化","slug":"柯里化-偏函数-反柯里化","date":"2020-07-21T05:56:00.000Z","updated":"2020-07-21T06:11:20.100Z","comments":true,"path":"ke-li-hua-pian-han-shu-fan-ke-li-hua.html","link":"","permalink":"https://www.ding51.cn/ke-li-hua-pian-han-shu-fan-ke-li-hua.html","excerpt":"","text":"1. 柯里化 描述：柯里化算是特殊的偏函数，把一个多参数函数转换成多个单参数函数，也就是说把一个具有n个参数的函数转换成n个一元函数 特点： 1、闭包，调用柯里化函数（currie）返回另外一个函数（_myFn），通过闭包缓存真正执行运算的函数（fn）和参数（args） 2、 通过返回的函数传递参数，并进行判断，如果参数已经传递够了，就执行函数（fn)并返回结果，如果参数还没传递完，则继续返回函数（_myFn）接收参数 例子： // 正常写法 const add = (a + b) => a+b const resAdd = add(2, 3) // 柯里化 const add = a => b => a+b; const resCurrie = add(2)(3) 2. 偏函数描述： 偏函数又叫局部应用，固定函数的一个或多个参数 特点：偏函数的代码比较简单，就是利用闭包缓存实际的执行方法（fn）和与之的参数（preset），然后返回一个接收剩余参数的方法，方法的实现就是执行fn并返回结果 举例： // 一般写法 // 封装一个ajax方法 function ajax (url, data, callback) { ... } // 调用ajax方法， ajax('http://xxx.com', { a: 'aa' }, function () { // 回调 A }) ajax('http://xxx.com', { b: 'bb' }, function () { // 回调 B }) ajax('http://xxx.com', { y: 'yy' }, function () { // 回调 Y }) // 上面url参数重复填写 // 偏函数 function partial (url) { return function (data, cb) { ajax(url, data, cb) } } // 调用偏函数 const partialAjax = partial('http://lyn.com') // 发送ajax请求 partialAjax({ a: 'aa' }, function () { // 回调 A }) partialAjax({ b: 'bb' }, function () { // 回调 B }) partialAjax({ y: 'yy' }, function () { // 回调 Y }) 3.反柯里化描述： 反柯里化作用和偏函数相反，它的本质是增强一个函数的使用范围，让一个对象可以使用不属于对象自己的方法，就像apply、call、bind（也有偏函数的作用）的作用，而事实上反柯里化就是通过apply、call方法实现的。 举例： Function.prototype.uncurrie = function (obj) { // 参数obj是需要操作的对象 // 这里的this是指obj对象需要借用的方法，比如示例中的Array.prototype.push const fn = this return function (...args) { // 难点，以下代码相当于：fn.call(obj, ...args), 没理解请看下面的 “代码解析” 部分 return Function.prototype.call.apply(fn, [obj, ...args]) } } // 示例，导出Array.prototype.push方法给对象使用 const obj = { a: 'aa' } const push = Array.prototype.push.uncurrie(obj) push('b') push('c') console.log(obj) // {0: \"b\", 1: \"c\", a: \"aa\", length: 2} 参考：https://segmentfault.com/a/1190000022416728","categories":[],"tags":[{"name":"柯里化","slug":"柯里化","permalink":"https://www.ding51.cn/tags/柯里化/"},{"name":"偏函数","slug":"偏函数","permalink":"https://www.ding51.cn/tags/偏函数/"},{"name":"反柯里化","slug":"反柯里化","permalink":"https://www.ding51.cn/tags/反柯里化/"}]},{"title":"开机自启全屏设置chrome和firefox","slug":"ubuntu设置chrome和firefox开机全屏自启","date":"2020-06-19T07:36:00.000Z","updated":"2020-11-09T08:31:04.132Z","comments":true,"path":"ubuntu-she-zhi-chrome-he-firefox-kai-ji-quan-ping-zi-qi.html","link":"","permalink":"https://www.ding51.cn/ubuntu-she-zhi-chrome-he-firefox-kai-ji-quan-ping-zi-qi.html","excerpt":"","text":"一. 设置开机自启浏览器注： 此设置基于ubuntu系统1.新建autostar# 查看有没有autostart文件,没有新建 $ mkdir ~/.config/autostart 2.拷贝.desktop 到 autostart# 查找应用位置(如谷歌) sudo find / -name *google-chrome.desktop $ cp /usr/share/applications/firefox.desktop ~/.config/autostart/ 3.文件授权$ chmod +x ~/.config/autostart/firefox.desktop 二. 设置火狐全屏设置1.火狐浏览器自动全屏插件： Auto Fullscreen 注：容易安装成另外一款，特此标注 2.设置浏览器打开不显示上次的历史记录 三. 谷歌全屏，不输密码设置1.每次打开谷歌需要输入密码，免密设置如下 2.谷歌浏览器全屏设置 在command输入最后写入启动打开的地址和全屏参数：http://localhost:8000 --start-fullscreen /usr/bin/google-chrome-stable %U http://localhost:8000 --start-fullscreen 保存即可!四. win10 自启项设置1.按下win+R调出运行窗口，并输入“shell:startup”即可进入开机启动文件夹 2.添加启动项，可以将软件快捷方式移入开机启动文件夹中，即可","categories":[{"name":"ubuntu浏览器自启设置","slug":"ubuntu浏览器自启设置","permalink":"https://www.ding51.cn/categories/ubuntu浏览器自启设置/"}],"tags":[{"name":"ubuntu ","slug":"ubuntu","permalink":"https://www.ding51.cn/tags/ubuntu/"},{"name":"浏览器自启全屏","slug":"浏览器自启全屏","permalink":"https://www.ding51.cn/tags/浏览器自启全屏/"}]},{"title":"js事件","slug":"js事件流","date":"2019-12-31T08:26:13.000Z","updated":"2020-07-22T07:54:21.830Z","comments":true,"path":"js-shi-jian-liu.html","link":"","permalink":"https://www.ding51.cn/js-shi-jian-liu.html","excerpt":"","text":"js事件概念:HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件、页面的滚动事件onscroll等等,当页面产生一个事件时,该事件会在元素节点与根节点之间的路径传播，路径所经过的节点都会收到该事件，这个传播的过程叫做DOM事件流一. 当页面产生一个事件时经过的三个阶段: 事件捕获阶段document顶部先接收到事件，依次往下传播到事件节点（可以借用addEventListener来模拟事件捕获流） 处于目标阶段 事件冒泡阶段事件开始时由最具体的元素接收，然后逐级向上传播执行流程: 示例代码:说明: addEventListener 第一个参数: 事件名称, 第二个参数: 触发函数, 第三个参数: 布尔 默认false, true表示捕获阶段触发, fals事件冒泡阶段 三：js阻止事件冒泡和默认事件阻止事件冒泡:w3c:e.stopPropagationie:window.event.cancelBubble = true 默认事件：是指目标元素的默认行为比如a标签会跳转链接 form会提交表单w3c:e.preventDefault()ie:window.event.returnValue = false 另外js中的return false也可以阻止默认行为,jq中的return false既可以阻止默认行为也可以阻止冒泡 // 事件绑定的方式, 用return false; 不会阻止默认事件 oBtn.addEventListener('click', function (e) { console.log('btn处于事件冒泡阶段 - 5'); return false; }, false); // 以下代码 return false;可以阻止 oBtn.onclick = function () { return false; }; return false ? 参考文章 四、target 和 currentTargetevent.target指向引起触发事件的元素，而event.currentTarget则是事件绑定监听的元素。 五、宏任务和微任务macrotask（宏任务）：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask（微任务）：Promise，process.nextTick等","categories":[],"tags":[]},{"title":"节流和防抖","slug":"节流和防抖","date":"2019-12-18T07:51:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"jie-liu-he-fang-dou.html","link":"","permalink":"https://www.ding51.cn/jie-liu-he-fang-dou.html","excerpt":"","text":"函数防抖(debounce)含义: 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 debounce 使用场景 search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 频繁操作点赞和取消点赞，因此需要获取最后一次操作结果并发送给服务器 代码示例: &lt;Input placeholder=\"搜索\" onClick={this.debounce(this.handleSearch, 400)}/> /** * 防抖函数--异步搜索 */ private debounce = (fn: Function, delay: number = 500) => { let timeout = null; let _this = this; return function() { let args = arguments; clearTimeout(timeout); timeout = setTimeout(() => { fn.apply(_this, args); }, delay); }; } 函数节流(throttle)含义: 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 throttle使用场景 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断 代码示例: /** * 节流函数 */ private throttle = (fn: Function, delay: number = 500) => { let _this = this; let isRuning = false; return function () { let args = arguments; if (isRuning) { return; } isRuning = true; setTimeout(() => { isRuning = false; fn.apply(_this, args); }, delay); }; } 总结：函数防抖： 将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流： 使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/tags/js/"},{"name":"防抖","slug":"防抖","permalink":"https://www.ding51.cn/tags/防抖/"},{"name":"节流","slug":"节流","permalink":"https://www.ding51.cn/tags/节流/"}]},{"title":"小程序web-view中使用JSSDK,ios安卓踩坑","slug":"web-view-react中JSSDK","date":"2019-12-17T10:41:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"web-view-react-zhong-jssdk.html","link":"","permalink":"https://www.ding51.cn/web-view-react-zhong-jssdk.html","excerpt":"","text":"背景: 在小程序中使用web-view使用react,需要调用相关JSSDK的接口配置, IOS能正常使用,安卓却签名错误invalid signature基础配置按照官方文档来, 这里说明下配置注意事项: 引入微信jssdk，wx.config所用到的工具函数，appid 要使用公众号的APPID，如果APPID使用的是小程序的APPID，config时会报签名无效，要注意config签名参数的大小写 在公众号里面配置,js安全域名配置成web-view的域名 以上配置成功后, 在IOS中使用都能正常使用, 却在安卓机器上使用签名失败invalid signature, 硬是没在网上找到相关解决方案, 很多都是安卓使用正常, IOS使用异常. 煎熬两天综合了其他问题,经过尝试终于通了,记录一下解决方案, 希望帮助遇到同样问题的人 &lt;script type=\"text/javascript\" src=\"https://res.wx.qq.com/open/js/jweixin-1.3.2.js\">&lt;/script> &lt;script> // web-view进入react的第一时间, index.html时记录url if (typeof window.entryUrl === 'undefined' || window.entryUrl === '') { window.entryUrl = location.href.split('#')[0]; } &lt;/script> // 发送给后端签名时 这里就需要区分了!! let isAnd = /(Android)/i.test(navigator.userAgent); //安卓终端 let url = isAnd ? encodeURIComponent(window['entryUrl']) : encodeURIComponent(location.href.split('/?')[0]); 分析: 我这里进入web-view的地址是https://dev.xxx.com?openId=xxx&amp;token=xxxx 然后进入默认路由页面url已经变成https://dev.xxx.com/workbench?appkey=xxx SPA 的router路由机制,在安卓和ios的不同, jssdk url签名的ios只认第一次的路由，我只需要传第一次路由给后端就行","categories":[{"name":"小程序","slug":"小程序","permalink":"https://www.ding51.cn/categories/小程序/"}],"tags":[{"name":"JSSDK","slug":"JSSDK","permalink":"https://www.ding51.cn/tags/JSSDK/"},{"name":"小程序","slug":"小程序","permalink":"https://www.ding51.cn/tags/小程序/"}]},{"title":"git常用的指令和问题处理","slug":"git常用到的指令","date":"2019-03-27T18:44:00.000Z","updated":"2021-08-30T03:06:19.176Z","comments":true,"path":"git-chang-yong-dao-de-zhi-ling.html","link":"","permalink":"https://www.ding51.cn/git-chang-yong-dao-de-zhi-ling.html","excerpt":"","text":"一、开发时常用的指令1. github配置 ssh key配置cd ~/.ssh 查看是否有id_rsa、id_rsa.pub文件，如果没有需要手动生成。 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 一路回车.登录github。打开setting-&gt;SSH keys，点击右上角 New SSH key，把生成好的公钥id_rsa.pub放进 key输入框中 2. git常用命令git branch -a //显示分支一览表，同时确认当前所在的分支git checkout -b aaa //创建名为aaa的分支，并且切换到aaa分支 //创建名为aaa的分支git checkout aaa // 切换到aaa分支git checkout - //切换到上一分支 本地代码修改了，需要提交到另外一个未建新分支git checkout -b newBranch // 直接在本地新建git push origin newBranch // add&amp;&amp;commit后，直接推送该分支 同步远程分支列表（如：本地缺少分支，远程上有新分支添加’updateBranch’）git branch -a // 查看本地和远程的分支git remote update origin --prune // 更新本地分支列表。git checkout updateBranch // 直接切换到该新分支updateBranch 不小心commit了一个不应该commit的修改，但是还没有push，想回滚那个commit.命令：git log // 查看提交日志 复制下commit_idgit reset --hard commit_id // 回滚 查看更改的记录(后面可以加具体的文件名)git diff 合并本地 分支代码git merge test // test为合并进来的分支 远程仓库查看git remote -v 添加远程仓库git remote add upstream https://github.com/xxxxx/kts-portal.git 重置远程仓库路径git remote set-url upstream https://github.com/xxxxxx/SpringBoot.git 更新远程分支列表git remote update origin --prunegit remote update origin -p 拉取远程某个分支git pull upstream dev 3. commit 提交类型规范用于说明 commit 的类别，只允许使用下面7个标识。 feat：新功能（feature） fix：修补bug docs：文档（documentation） style： 格式（不影响代码运行的变动） refactor：重构（即不是新增功能，也不是修改bug的代码变动） test：增加测试 chore：构建过程或辅助工具的变动 4. tag 使用我们常常在代码封板时,使用git 创建一个tag ,这样一个不可修改的历史代码版本就像被我们封存起来一样,不论是运维发布拉取,或者以后的代码版本管理,都是十分方便的。 创建tag git tag &lt;name&gt;$ git tag v1.0 -m&quot;备注&quot; // 默认最近一次提交的commit $ git tag v1.0 &lt;commitID&gt; -m&quot;备注&quot; // 提交过的历史 打tag，找出对应的commit id 查看tag git tag 提交 $ git push origin --tags tag覆盖$ git tag -d V1.0 $ git push origin --tags 二、开发应用中出现的问题 解决1、Failed to connect to github.com port 443:connection timed out 或 fatal: unable to access &#39;https://github.com/xxxx&#39;: gnutls_handshake() failed: The TLS connection was non-properly terminated由于代理设置有错，为 http 错误配置了 https 的代理，导致出错。设置如下： git config --global http.proxy http://127.0.0.1:1080 git config --global http.proxy https://127.0.0.1:1080 git config --global --unset http.proxy git config --global --unset https.proxy","categories":[{"name":"git","slug":"git","permalink":"https://www.ding51.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.ding51.cn/tags/git/"}]},{"title":"对数组中的某对象排序","slug":"数组中的某对象排序","date":"2019-03-25T15:45:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"shu-zu-zhong-de-mou-dui-xiang-pai-xu.html","link":"","permalink":"https://www.ding51.cn/shu-zu-zhong-de-mou-dui-xiang-pai-xu.html","excerpt":"","text":"利用sort方法排序例子: 对一组数组中的年龄排序. var arr = [ {name:'zopp',age:0}, {name:'gpp',age:18}, {name:'yjj',age:8} ]; // 降序 function compare(name){ return function(a,b){ return a[name] - b[name]; } } // 打乱数组顺序 function disrupt(name){ return function(a,b){ return Math.random() > 0.5 ? -1 : 1; } } console.log(arr.sort(compare('age'))) 结果,: [ {name:&#39;zopp&#39;,age:0}, {name:&#39;yjj&#39;,age:8} {name:&#39;gpp&#39;,age:18}, ];","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.ding51.cn/tags/排序/"}]},{"title":"node版本升级管理","slug":"ode版本升级管理","date":"2019-03-24T14:38:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"ode-ban-ben-sheng-ji-guan-li.html","link":"","permalink":"https://www.ding51.cn/ode-ban-ben-sheng-ji-guan-li.html","excerpt":"","text":"升级或降级node,网上找了一大堆的资料,看着头皮发麻,只需两行代码的事情 1. sudo npm install -g n // 安装 2. sudo n v9.10.0 // 升级到某个版本 如:v9.10.0 3. sudo n stable // 升级到最稳当版本","categories":[{"name":"node","slug":"node","permalink":"https://www.ding51.cn/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://www.ding51.cn/tags/node/"}]},{"title":"如何创建发布NPM包?","slug":"创建发布NPM包","date":"2019-01-29T23:59:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"chuang-jian-fa-bu-npm-bao.html","link":"","permalink":"https://www.ding51.cn/chuang-jian-fa-bu-npm-bao.html","excerpt":"","text":"前言: 平时我们都是使用的别人写好的npm包, npm i xxx ,就直接安装好了使用,本文章介绍的是如何创建自己的封装好的npm包发布。 npm官网创建npm账户npm网站地址：https://www.npmjs.com/ 命令行工具登录npm npm login 验证登录是否成功 npm who am i如果成功会输入你npm个人信息 内镜检测: npm config get registry 如果输出 http://registry.npmjs.org就配置正确, 否则要设置镜像npm config set registry http://registry.npmjs.org 创建npm库npm init接下来就是一长串表单： name：填写你这个包的名字，默认是你这个文件夹的名字。不过这里要着重说一下，最好先去npm上找一下有没有同名的包。最好的测试方式就是，在命令行里面输入npm install 你要取的名字，如果报错，那么很好，npm上没有跟你同名的包，你可以放心大胆地把包发布出去。如果成功下载下来了。。。那么很不幸，改名字吧。。。 version：你这个包的版本，默认是1.0.0 description：其实我也不知道是什么，按回车就好了。。。，这个用一句话描述你的包是干嘛用的，比如我就直接：‘a plugin for express.register routes base on file path’ entry point：入口文件，默认是Index.js，你也可以自己填写你自己的文件名 test command：测试命令，这个直接回车就好了，因为目前还不需要这个。 git repository：这个是git仓库地址，如果你的包是先放到github上或者其他git仓库里，这时候你的文件夹里面会存在一个隐藏的.git目录，npm会读到这个目录作为这一项的默认值。如果没有的话，直接回车继续。 keyword：这个是一个重点，这个关系到有多少人会搜到你的npm包。尽量使用贴切的关键字作为这个包的索引。我这个包嘛，第一是在express下工作的，然后又是一个插件plugin，然后又是一个注册路由route用的，而这个路由又是基于文件目录dir，所以很好就得出我的包的索引关键字。 author：写你的账号或者你的github账号吧 license：这个直接回车，开源文件来着。。。然后它就会问你Are you ok? 直接回车最后生成package.json 同级目录下新建index.js并编写内容 exports.sayHello=function(){ return \"Hello.\"; }; 发布npm包 npm publish发布完成会提示 验证是否发布成功 npm install xxx包 更新版本npm version &lt;update_type&gt; -m &quot;&lt;message&gt;&quot;其中update_type 有三种：patch增加一位补丁号（比如 1.1.1 -&gt; 1.1.2）minor增加一位小版本号（比如 1.1.1 -&gt; 1.2.0）major增加一位大版本号（比如 1.1.1 -&gt; 2.0.0）比如：npm version patch -m &quot;Version %s - v1.0.2&quot;最后提交更新的版本：npm publish 撤销自己发布的版本。这只是一个测试的包，最好当然还是撤销下来npm --force unpublish test_npm 注: 删除要用force强制删除。超过24小时就不能删除了","categories":[{"name":"npm","slug":"npm","permalink":"https://www.ding51.cn/categories/npm/"}],"tags":[{"name":"创建npm包","slug":"创建npm包","permalink":"https://www.ding51.cn/tags/创建npm包/"}]},{"title":"JS如何优雅的写判断语句(二)","slug":"JS如何优雅的写判断语句-二","date":"2019-01-20T20:01:00.000Z","updated":"2020-05-22T09:00:23.404Z","comments":true,"path":"js-ru-he-you-ya-de-xie-pan-duan-yu-ju-er.html","link":"","permalink":"https://www.ding51.cn/js-ru-he-you-ya-de-xie-pan-duan-yu-ju-er.html","excerpt":"","text":"1.多重判断时使用 Array.includes2.更少的嵌套，尽早 return3.使用默认参数和解构4.倾向于遍历对象而不是 Switch 语句5.对 所有/部分 判断使用 Array.every &amp; Array.some 1.多重判断时使用 Array.includes例子: function test(fruit) { if (fruit == 'apple' || fruit == 'strawberry') { console.log('red'); } } 用 Array.includes (Array.includes)重写条件语句 function test(fruit) { const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) { console.log('red'); } } 把条件放入数组,利用includes判断,这样一来，代码看起来更整洁 2.更少的嵌套，尽早 Return例子: function test(fruit, quantity) { const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: fruit 必须有值 if (fruit) { // 条件 2: 必须是red的 if (redFruits.includes(fruit)) { console.log('red'); // 条件 3: quantity大于10 if (quantity > 10) { console.log('big quantity'); } } } else { throw new Error('No fruit!'); } } // 测试结果 test(null); // error: No fruits test('apple'); // print: red test('apple', 20); // print: red, big quantity 当发现无效语句时，尽早Return,少嵌套 function test(fruit, quantity) { const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: 尽早抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件 2: 当水果不是红色时停止继续执行 if (!redFruits.includes(fruit)) return; console.log('red'); // 条件 3: 必须是大质量的 if (quantity > 10) { console.log('big quantity'); } } 3.使用默认参数和解构需要检查 null / undefined的值和指定默认值,例子: // fruit是一个对象{name: 'xx'} , quantity数量设置默认值为 1 function test(fruit, quantity) { // 如果 quantity 参数没有传入，设置默认值为 1 const q = quantity || 1; // 当值存在时打印 fruit 的值 if (fruit &amp;&amp; fruit.name){ console.log(`We have ${quantity} ${fruit.name}!`); }else { console.log('unknown'); } } 使用默认参数和解构 代替 // fruit是一个对象{name: 'xx'} , quantity数量 function test({name} = {}, quantity = 1) { console.log (name || 'unknown'); } 4.倾向于对象遍历而不是if/else Switch语句利用对象代替,可以参考上一篇文章 const fruitColor = { red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum'] }; function test(color) { return fruitColor[color] || []; } 5.对 所有/部分 判断使用Array.every &amp; Array.somees6中every,当数组中的数据必须每个满足条件返回true var computers = [ {name:\"Apple\",ram:8}, {name:\"IBM\",ram:4}, {name:\"Acer\",ram:32}, ]; computers.every(computer => computer.ram > 3) // true computers.every(computer => computer.ram > 10) // false some,当数组中只要一条数据满足条件,就返回true var computers = [ {name:\"Apple\",ram:8}, {name:\"IBM\",ram:4}, {name:\"Acer\",ram:32}, ]; computers.some(computer => computer.ram > 8) // true computers.some(computer => computer.ram > 32) // false","categories":[],"tags":[{"name":"js优化","slug":"js优化","permalink":"https://www.ding51.cn/tags/js优化/"}]},{"title":"JS如何优雅的写判断语句(一)","slug":"JS如何优雅的写判断语句","date":"2019-01-20T17:25:00.000Z","updated":"2020-05-22T09:00:23.404Z","comments":true,"path":"js-ru-he-you-ya-de-xie-pan-duan-yu-ju.html","link":"","permalink":"https://www.ding51.cn/js-ru-he-you-ya-de-xie-pan-duan-yu-ju.html","excerpt":"","text":"一.复杂判断优雅写法前言:js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂。 1.1 一元条件判断一般的写法 if/else 或者 switch/** * @param {number} status 活动状态：1 开团进行 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status) =>{ if (status === 1) { sendLog('processing') jumpTo('IndexPage') } else if (status === 2) { sendLog('fail') jumpTo('FailPage') } else if (status === 3) { sendLog('fail') jumpTo('FailPage') } else if (status === 4) { sendLog('success') jumpTo('SuccessPage') } else if (status === 5) { sendLog('cancel') jumpTo('CancelPage') } else { sendLog('other') jumpTo('Index') } } 优化方法一,将判断条件作为对象的属性名，将处理逻辑作为对象的属性值 const actions = { '1': ['processing', 'IndexPage'], '2': ['fail', 'FailPage'], '3': ['fail', 'FailPage'], '4': ['success', 'SuccessPage'], '5': ['cancel', 'CancelPage'], 'default': ['other', 'Index'], } const onButtonClick = (status) = >{ let action = actions[status] || actions['default'], let logName = action[0], let pageName = action[1]; sendLog(logName); jumpTo(pageName); } 优化方法二,es6里的Map对象 const actions = new Map([ [1, ['processing', 'IndexPage']], [2, ['fail', 'FailPage']], [3, ['fail', 'FailPage']], [4, ['success', 'SuccessPage']], [5, ['cancel', 'CancelPage']], ['default', ['other', 'Index']]]) const onButtonClick = (status) => { let action=actions.get(status)||actions.get('default'); sendLog(action[0]); jumpTo(action[1]); } 1.2 多条件同时判断多条件普通写法 if/elseconst onButtonClick = (status, identity) => { if (identity == 'guest') { if (status == 1) { } else if (status == 2) { } else if (status == 3) { } else if (status == 4) { } else if (status == 5) { } else {} } else if (identity == 'master') { if (status == 1) { } else if (status == 2) { } else if (status == 3) { } else if (status == 4) { } else if (status == 5) { } else {} } } 优化写法一: 利用对象object 或者 map // 利用object对象 字符串拼接 const actions = { 'guest_1': () = >{}, 'guest_2': () = >{}, //.... } const onButtonClick = (identity, status) => { let action = actions[`$ {identity}_${status}`] || actions['default']; action.call(this); } // 利用map对象 字符串拼接 const actions=new Map([ ['guest_1',()=>{}], ['guest_2',()=>{}], ['master_1',()=>{}], ['master_2',()=>{}], ['default',()=>{}], ]); const onButtonClick = (identity, status) => { let action = actions.get(`$ {identity}_${status}`) || actions.get('default'); action.call(this); } 不拼接优化方法二: 用Map对象，以Object对象作为key const actions = new Map([ [{identity: 'guest',status: 1},() = >{}], [{identity: 'guest', status: 2}, () = >{}], ]) const onButtonClick = (identity, status) => { let action = [...actions].filter(([key, value]) =>(key.identity == identity &amp;&amp; key.status == status)); action.forEach(([key, value]) = >value.call(this)); } 注意: 不能直接actions.get({identity: &#39;guest&#39;,status: 1}).call(this)调用 会报错,因为{identity: ‘guest’,status: 1},和map中定义的不是指的同一个对象地址","categories":[],"tags":[{"name":"js优化","slug":"js优化","permalink":"https://www.ding51.cn/tags/js优化/"},{"name":"map对象","slug":"map对象","permalink":"https://www.ding51.cn/tags/map对象/"}]},{"title":"input只能输入数字并限制长度","slug":"input只能输入数字并限制长度","date":"2018-12-26T14:01:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"input-zhi-neng-shu-ru-shu-zi-bing-xian-zhi-chang-du.html","link":"","permalink":"https://www.ding51.cn/input-zhi-neng-shu-ru-shu-zi-bing-xian-zhi-chang-du.html","excerpt":"","text":"随笔记录情景:要求只能输入数字,且限制长度,在谷歌浏览器移除input[number]的上下箭头样式 &lt;input type=&quot;text&quot; maxlength=&quot;5&quot; /&gt; 效果ok，当 &lt;input type=&quot;number&quot; maxlength=&quot;5&quot; /&gt;时maxlength失效，长度可以无限输入 解决参考代码: &lt;style> /*在chrome下移除input[number]的上下箭头*/ input::-webkit-outer-spin-button, input::-webkit-inner-spin-button{ -webkit-appearance: none !important; margin: 0; } /*在firefox下移除input[number]的上下箭头*/ input[type=\"number\"]{-moz-appearance:textfield;} &lt;style> &lt;input type=\"number\" oninput=\"if(value.length>5)value=value.slice(0,5)\">","categories":[{"name":"html5","slug":"html5","permalink":"https://www.ding51.cn/categories/html5/"}],"tags":[{"name":"htm5","slug":"htm5","permalink":"https://www.ding51.cn/tags/htm5/"},{"name":"css","slug":"css","permalink":"https://www.ding51.cn/tags/css/"}]},{"title":"&& || 运算","slug":"运算","date":"2018-12-26T03:39:00.000Z","updated":"2021-02-18T06:28:17.251Z","comments":true,"path":"yun-suan.html","link":"","permalink":"https://www.ding51.cn/yun-suan.html","excerpt":"","text":"1; // true \"0\" // true 0; // false false; // false true; // true \"string\"; // true \"\" // false null // false NaN // false 1.&amp;&amp; Boolean判断，遇到假的值，返回该假值，停止后面判断。 全为真的值，返回最后一个值。 返回第一个遇到的假值。没有假值，返回最后一个真值 // 举例 's' &amp;&amp; '0' &amp;&amp; 0 &amp;&amp; false //结果：0 's','0'为真，计算到 0，值为假。返回该值，停止比较 // 全真 's' &amp;&amp; '0' &amp;&amp; true &amp;&amp; '123' // 123 2.|| Boolean判断，返回第一个真的值，停止后面判断。 全假值，返回最后一个值。 's' || false || '0' || true // 's' 0 || false || null || '0' || false // '0' // 全假 false || 0 || null 3.&amp;&amp;优先级高，先算&amp;&amp; 再 ||''||null||3||4&amp;&amp;5&amp;&amp;0 // 先计算 4&amp;&amp;5&amp;&amp;0 => 0 ''||null||3||0 // 遇到第一个真值3 返回 3 //结果","categories":[{"name":"js基础","slug":"js基础","permalink":"https://www.ding51.cn/categories/js基础/"}],"tags":[{"name":"&&","slug":"","permalink":"https://www.ding51.cn/tags//"},{"name":"||","slug":"","permalink":"https://www.ding51.cn/tags//"},{"name":"运算符","slug":"运算符","permalink":"https://www.ding51.cn/tags/运算符/"}]},{"title":"React生命周期(v16.3 之前版本)","slug":"React新旧生命周期对比-v16-3","date":"2018-12-09T21:14:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"react-xin-jiu-sheng-ming-zhou-qi-dui-bi-v16-3.html","link":"","permalink":"https://www.ding51.cn/react-xin-jiu-sheng-ming-zhou-qi-dui-bi-v16-3.html","excerpt":"","text":"生命周期对react非常重要,对很多新手来说,搞不懂哪个阶段该做什么事情,迷茫,乱用函数,导致性能下降,死循环. 文章主要记录了react平时常用的生命周期函数,及平时开发遇到的注意事项,自从react v16.3更新后,其生命周期还是发生很大的改变, 这里介绍v16.3之前的版本 React 生命周期主要包括三个阶段：1. 初始化阶段2. 运行中阶段3. 销毁阶段(注:结合图来看文章有助理解) 1. 初始化阶段1-1.设置组件默认属性方法一 挂载组件的时候设置 props(比较常用) var data = [{title: 'Hello'}]; &lt;Hello data={data} /> 方法二 defaultProps在组件内部定义,此方法编译才生效,es6 会报错,使用es7以上(详情) static defaultProps = { age: 18 } 在组件外部属性定义 Greeting.defaultProps = { name: '我是props的默认值！' }; ReactDOM.render( &lt;Greeting />, document.getElementById('example') ); 1-2.组件的初始化状态 stateconstructor(props){ super(props); // 不加super()，导致了this的 Reference Error this.state={}; } super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。super(props):传递props作为super()的参数，那就是你需要在构造函数内使用this.props 1-3.componentWillMount因为componentWillMount是在render之前执行，所以在这个方法中setState不会发生重新渲染(re-render),通常情况下，推荐用constructor()方法代替.提示: 很多时候喜欢这里去做一些初始化数据的请求,你会发现数据还没请求到就渲染render()了,当请求到数据后setState再渲染出数据.依然重复渲染. 建议初始化数据都在componentDidMount()中使用,新版本将去掉这个函数. 1-4.render该方法会创建一个虚拟DOM，用来表示组件的输出。对于一个组件来讲，render方法是唯一一个必需的方法。render方法需要满足下面几点： 只能通过 this.props 和 this.state 访问数据（不能修改） 可以返回 null,false 或者任何React组件 只能出现一个顶级组件，不能返回一组元素 不能改变组件的状态 不能修改DOM的输出render方法返回的结果并不是真正的DOM元素，而是一个虚拟的表现，类似于一个DOM tree的结构的对象。 1-5. componentDidMount一般情况在这里做初始化异步数据请求 这个方法会在render()之后立即执行； 这里可以对DOM进行操作，这个函数之后ref变成实际的DOM 2. 组件运行阶段此时组件已经渲染好并且用户可以与它进行交互，比如鼠标点击，手指点按，或者其它的一些事件，导致应用状态的改变，你将会看到下面的方法依次被调用2-1.componentWillReceiveProps组件的 props 属性可以通过父组件来更改，这时，componentWillReceiveProps 将来被调用。可以在这个方法里更新 state,以触发 render 方法重新渲染组件。 componentWillReceiveProps: function(nextProps){ if(nextProps.checked !== undefined){ this.setState({ checked: nextProps.checked }) } } 2-2.shouldComponentUpdate(nextProps, nextState)在接收新的props或state时确定是否发生重新渲染，默认情况返回true，表示会发生重新渲染注意 这个方法在首次渲染时或者forceUpdate()时不会触发; 这个方法如果返回false, 那么props或state发生改变的时候会阻止子组件发生重新渲染; 目前，如果返回false, 那么componentWillUpdate(nextProps, nextState), render(), componentDidUpdate()都不会被触发; 2-3.componentWillUpdate在props或state发生改变或者shouldComponentUpdate(nextProps, nextState)触发后, 在render()之前.千万不要在这个函数中调用this.setState()方法,死循环.结合图表看.2-4.render同上 1-42-5.componentDidUpdate(object prevProps, object prevState)这个方法和 componentDidMount 类似 3.componentWillUnmount组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器， 关闭抽屉弹框，取消Redux的订阅事件等等. 总结对比生命周期实例 demo","categories":[{"name":"react","slug":"react","permalink":"https://www.ding51.cn/categories/react/"}],"tags":[{"name":"react生命周期","slug":"react生命周期","permalink":"https://www.ding51.cn/tags/react生命周期/"}]},{"title":"ES6中箭头函数和function的区别","slug":"ES6中箭头函数和function的区别","date":"2018-11-27T13:45:00.000Z","updated":"2020-08-10T07:33:58.055Z","comments":true,"path":"es6-zhong-jian-tou-han-shu-he-function-de-qu-bie.html","link":"","permalink":"https://www.ding51.cn/es6-zhong-jian-tou-han-shu-he-function-de-qu-bie.html","excerpt":"","text":"箭头函数和function的区别总结1.箭头函数与function定义函数的写法//function function fn(a, b){ return a + b; } // 箭头函数 var foo = (a, b)=>{ return a + b }; 2.this的指向1.使用function定义的函数，this的指向随着调用环境的变化而变化的。 //使用function定义的函数 function foo(){ console.log(this); } var obj = { aa: foo }; foo(); //Window obj.aa() //obj { aa: foo } 2.而箭头函数中的this指向是固定不变的，一直指向的是定义它的环境，最近的作用域。 //使用箭头函数定义函数 var foo = () => { console.log(this) }; var obj = { aa:foo }; foo(); //Window obj.aa(); //Window let a = { foo: 1, bar: () => console.log(this.foo) } a.bar() //undefined 原因:箭头函数中的this并不是指向a这个对象。对象a并不能构成一个作用域，所以再往上到达全局作用域，this就指向全局作用域,这里this指向Window。 3.构造函数//使用function方法定义构造函数 function Person(name, age){ this.name = name; this.age = age; } var lenhart = new Person(lenhart, 25); console.log(lenhart); //{name: 'lenhart', age: 25} function是可以定义构造函数的，而箭头函数是不行的。 //尝试使用箭头函数 var Person = (name, age) =>{ this.name = name; this.age = age; }; var lenhart = new Person('lenhart', 25); //Uncaught TypeError: Person is not a constructor 4.变量提升由于js的内存机制，function的级别最高，而用箭头函数定义函数的时候，需要var(let const定义的时候更不必说)关键词，而var所定义的变量不能得到变量提升，故箭头函数一定要定义于调用之前！ foo(); //123 function foo(){ console.log('123'); } arrowFn(); //Uncaught TypeError: arrowFn is not a function var arrowFn = () => { console.log('456'); };","categories":[{"name":"ES6","slug":"ES6","permalink":"https://www.ding51.cn/categories/ES6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/tags/js/"},{"name":"箭头函数this","slug":"箭头函数this","permalink":"https://www.ding51.cn/tags/箭头函数this/"},{"name":"ES6","slug":"ES6","permalink":"https://www.ding51.cn/tags/ES6/"}]},{"title":"Nginx 搭建和配置","slug":"Nginx-搭建和配置","date":"2018-11-21T02:01:00.000Z","updated":"2021-07-28T10:01:56.117Z","comments":true,"path":"nginx-da-jian-he-pei-zhi.html","link":"","permalink":"https://www.ding51.cn/nginx-da-jian-he-pei-zhi.html","excerpt":"","text":"本文章适合新手,其中含有我在实际中遇到的问题解决分享,服务器在搬瓦工租的,不多废话直接上干货 一、Ubuntu环境： 操作系统：Ubuntu 18.04.4 Nginx搭建1.安装 nginxsudo apt update sudo apt install nginx nginx -v 相关命令# 启动 service nginx start # 停止 service nginx stop # 重起 service nginx restart sudo systemctl restart nginx nginx.conf 文件，路径为：/etc/nginx/nginx.conf常规配置如下： worker_processes 1; events { worker_connections 1024; } http { include mime.types; default_type application/octet-stream; sendfile on; keepalive_timeout 65; gzip on; gzip_vary on; gzip_comp_level 6; gzip_buffers 16 8k; gzip_min_length 1000; gzip_proxied any; gzip_disable \"msie6\"; #gzip_http_version 1.0; gzip_types text/plain text/css application/json application/x-javascript text/xml application/xml application/xml+rss text/javascript application/javascript; server { #error_page 404 /404.html; error_page 500 502 503 504 /50x.html; location = /50x.html { root html; } listen 80; server_name localhost; location ~ .*\\.(css|js|swf|html|htm|pdf)$ { root /var/www/html; autoindex on; index index.html index.htm; } location / { charset utf-8; root /var/www/html; index index.html index.htm; try_files $uri /index.html; } } } default 服务主机配置文件，路径为：/etc/nginx/sites-available/default 默认页面index.html路径： /var/www/html 二、CenOS环境： 操作系统：CenOS 6 x86 Nginx 版本：1.14.0 Nginx搭建1.第一步 创建源配置在/etc/yum.repos.d/目录下创建一个源配置文件nginx.repo cd /etc/yum.repos.d/ vim nginx.repo 填写如下内容： [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 保存，则会产生一个/etc/yum.repos.d/nginx.repo文件。 2.第二步 安装直接执行如下指令即可自动安装好Nginx： yum install nginx -y 安装完成，下面直接就可以启动Nginx了： /etc/init.d/nginx start 现在Nginx已经启动了，直接访问服务器就能看到Nginx欢迎页面了的。如果还无法访问:方法一:查看下服务器上端口是否80(阿里云上配下80端口)。方法二:需配置一下Linux防火墙,以此执行如下命令: iptables -I INPUT 5 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT service iptables save service iptables restart Nginx的相关命令： /etc/init.d/nginx start # 启动Nginx服务 /etc/init.d/nginx stop # 停止Nginx服务 /etc/nginx/nginx.conf # Nginx配置文件位置 chkconfig nginx on #设为开机启动 第三步 前端小优化 nginx开启gzip和缓存配置 (nginx.conf)进入nginx 配置文件vim /etc/nginx/nginx.conf,添加如下配置: # 开启gzip gzip on; # 启用gzip压缩的最小文件，小于设置值的文件将不会压缩 gzip_min_length 1k; # gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明 gzip_comp_level 2; # 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。 gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml; # 是否在http header中添加Vary: Accept-Encoding，建议开启 gzip_vary on; # 禁用IE 6 gzip gzip_disable \"MSIE [1-6]\\.\"; # 开启缓存 location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ { access_log off; expires 30d; } location ~* ^.+\\.(css|js|txt|xml|swf|wav)$ { access_log off; expires 24h; } location ~* ^.+\\.(html|htm)$ { expires 1h; } location ~* ^.+\\.(eot|ttf|otf|woff|svg)$ { access_log off; expires max; } # 格式 # expires 30s; # expires 30m; # expires 2h; # expires 30d; 相关报错问题处理1.vim使用报错:-bash: vim: command not found 使用命令 : yum -y install vim* 2.解决Nginx下使用React-router(其他单页应用vue-router路由)刷新出现404问题server需要重定向到index ,进入配置 vim /etc/nginx/conf.d/default.conf server { listen 80; server_name zlzkj.io; index index.html; root /Volumes/Mac/www/antd-admin/; location / { try_files $uri $uri/ /index.html; // 指向index.html } } 至此，Nginx已经全部配置安装完成,如有问题欢迎留言或联系。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://www.ding51.cn/categories/服务器/"}],"tags":[{"name":"Nginx ","slug":"Nginx","permalink":"https://www.ding51.cn/tags/Nginx/"}]}]}