{"meta":{"title":"Ding Zuke's blog","subtitle":"个人博客","description":"一个web开发者的爬坑路","author":"丁祖科","url":"https://www.ding51.cn"},"pages":[{"title":"","date":"2020-05-22T09:00:23.407Z","updated":"2020-05-22T09:00:23.407Z","comments":true,"path":"google5d9a7416b18345fe.html","permalink":"https://www.ding51.cn/google5d9a7416b18345fe.html","excerpt":"","text":"google-site-verification: google5d9a7416b18345fe.html"},{"title":"about","date":"2018-11-13T02:55:06.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"about/index.html","permalink":"https://www.ding51.cn/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-11-14T06:06:53.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"categories/index.html","permalink":"https://www.ding51.cn/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-11-14T06:07:40.000Z","updated":"2020-05-22T09:00:23.424Z","comments":true,"path":"tags/index.html","permalink":"https://www.ding51.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"new指令实现 和 es5 es6对比","slug":"new过程实现","date":"2020-08-11T08:02:00.000Z","updated":"2020-08-11T09:00:08.822Z","comments":true,"path":"new-guo-cheng-shi-xian.html","link":"","permalink":"https://www.ding51.cn/new-guo-cheng-shi-xian.html","excerpt":"","text":"1、es5 new的过程 生成一个新对象 为这个对象设置prototype 使用this执行构造函数 返回这个对象 2、手写newfunction _new() { // 1.生成一个新对象 let obj= {}; // 第一个参数是构造函数 let [constructor, ...args] = [...arguments]; // 2.为这个对象设置prototype;实际上就是生产了一个新的上下文 obj.__proto__ = constructor.prototype; // 使用apply在obj作用域中调用构造器函数，属性和方法被添加到 this 引用的对象即obj中 let result = constructor.apply(obj, args); if (result &amp;&amp; (typeof (result) == \"object\" || typeof (result) == \"function\")) { // 如果构造函数执行的结果返回的是一个对象，那么返回这个对象 return result; } // 如果构造函数返回的不是一个对象，返回创建的新对象 return obj; } var person1=_new(Person, 20) // 相当于 var person1 = new Person(20); 3、es5和es6中new的实现对比// -------------------------es5----------------------------- function Point(){ this.x = x; //x，y定义在对象自身上面 this.y = y; } Point.prototype.add = function(){ console.log(this.x + this.y); } //静态属性 Person.total = 0; //静态方法 Point.counter = function(){ return 'staticFn'; } var p = new Point(2, 3); p.add(); //输出5 // -------------------------es6----------------------------- class Point{ constructor(x, y) { //相当于java中的构造函数，如果不写默认为空 this.x = x; //x，y定义在对象自身上面 this.y = y; } //静态属性 static total = 0; //静态方法 static counter(){ return 'staticFn'; } add() { //该方法定义在Point.prototype上 console.log(this.x + this.y); } } var p = new Point(2, 3); p.add(); //输出5 4、ES6中当函数用new关键词的时候，增加了new.target属性来判断当前调用的构造函数1、可以限制函数的调用，比如一定要用new命令来调用 function Person(name){ if(new.target === Person){ this.name = name; } else{ throw new Error('必须用new生成实例'); } } 2、限制类的调用方法，判断new.target是不是未定义。写出只能被继承使用的类。 class Shape { constructor() { if (new.target === Shape) { throw new Error('本类不能实例化'); } } } class Rectangle extends Shape { constructor(length, width) { super(); // ... } } var x = new Shape(); // 报错 var y = new Rectangle(3, 4); // 正确","categories":[],"tags":[{"name":"new过程","slug":"new过程","permalink":"https://www.ding51.cn/tags/new过程/"}]},{"title":"this 和 构造函数有return ","slug":"this指向-和-构造函数有return","date":"2020-08-11T03:31:00.000Z","updated":"2020-08-11T03:42:59.807Z","comments":true,"path":"this-zhi-xiang-he-gou-zao-han-shu-you-return.html","link":"","permalink":"https://www.ding51.cn/this-zhi-xiang-he-gou-zao-han-shu-you-return.html","excerpt":"","text":"一、 es5中 this 1.在普通函数中的this总是代表他的直接调用者，默认情况下指向windos 2.在严格模式下，没有直接调用者的函数中的this是undefined使用 3.call,apply,bind，this指向的是绑定的对象； 4.构造函数中的this 二、 es6 箭头函数中 this箭头函数中的this指向是固定不变的，指向的是定义它的环境，最近的作用域。 1、点击事件绑定的this指向 &lt;body> &lt;button class=\"draw\" id=\"draw\">Draw&lt;/button> &lt;div onclick=\"func(this)\" name=\"book1\">click div&lt;/div> &lt;script> function func(_this) { console.log(_this); // 当前点击的div console.log(this); // window } var drawDom = document.getElementById('draw'); drawDom.addEventListener('click',function(){ console.log(this) // 当前div }) drawDom.addEventListener('click',() => { console.log(this) // window }) &lt;/script> &lt;/body> 2、嵌套函数 和变量不同，关键字this没有作用域的限制，嵌套的函数不会从调用它的函数中继承this。 1、如果嵌套函数作为方法调用，其this的值指向调用它的对象。 2、如果嵌套函数作为函数调用，其this值不是全局对象（非严格模式下）就是undefined（严格模式下）。 很多人误以为调用嵌套函数时this会指向调用外层函数的上下文。如果你想访问这个外部函数的this值，需要将this的值保存在一个变量里，这个变量和内部函数都在同一个作用域内。通常用self来保存this。 ——《犀牛书》8.2 函数调用 举例说明 var name = \"windName\" var data = { name:' d a taNam e', fn: function (){ var name = \"fnName\" console.log(this .name ) //输出：dataName this指向data var fn2 = () =>{ var name = \"fn2Name\" console.log(this.name) //输出：dataName } var fn3 = function(){ var name = \"fn3Name\" console.log(this.name) //输出：windName } fn2(); fn3(); // ** 嵌套的函数调用 this指向window(非严格模式) } } data.fn(); // 作为方法调用 输出： dataName dataName windName var a = { foo: 1, bar: () => console.log(this.foo)//这里是箭头函数指向 定义该箭头函数的作用域 } a.bar() //undefined this指向的window 三、 当函数构造函数有return时候 1.return的是五种简单数据类型：String，Numbe r ，Boolean，Null，Undefined。 这种情况下，忽视return值，依然返回this对象。 2.return的是Object 引用类型。 这种情况下，不再返回this对象，而是返回return语句的返回值 // 正常情况 function A(){ this.age = 12; } var a = new A(); a.age // 12 //举例 function A(){ this.age = 12; return {} } var a = new A(); a.age // undefined return返回的是引用类型。返回的是 {} //举例 function A(){ this.age = 12; return {age: 99} } var a = new A(); a.age //输出： 99 return返回的是引用类型。返回的是 {age: 99} //举例 function A(){ this.age = 12; return 13 } var a = new A(); a.age // 输出：12 return 12 返回的数值类型，返回this的对象","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"this","slug":"this","permalink":"https://www.ding51.cn/tags/this/"},{"name":"构造函数return ","slug":"构造函数return","permalink":"https://www.ding51.cn/tags/构造函数return/"}]},{"title":"原型题-解析","slug":"原型链题-解析","date":"2020-08-06T01:59:00.000Z","updated":"2020-08-06T02:09:09.862Z","comments":true,"path":"yuan-xing-lian-ti-jie-xi.html","link":"","permalink":"https://www.ding51.cn/yuan-xing-lian-ti-jie-xi.html","excerpt":"","text":"题目如下： function Fun(){ var getName = function(){ console.log(1); } return this; } Fun.getName = function(){ console.log(2); } Fun.prototype.getName = function(){ console.log(3); } var getName = function(){ console.log(4); } function getName(){ console.log(5); } Fun().getName(); getName(); Fun(); new Fun().getName(); new new Fun().getName(); 结果： Fun().getName(); // 4 getName(); // 4 Fun(); // 无输出 返回Window对象 new Fun().getName(); // 3 new new Fun().getName(); // 3 首先明白变量和函数提升， 函数提升要比变量提升的优先级要高一些，且不会被变量声明覆盖，但是会被变量赋值之后覆盖。 // 举例说明 变量和函数提升（懂的自动跳过） a() function a() { console.log(1) } var a = function(){ console.log(2) } a() // 输出： 1 ， 2 // 执行的代码顺序如下 function a() { console.log(1) }; var a; a() // 输出 1 a = function(){ console.log(2) } a() // 输出2 详细解析：题目中变量提升后的写法（方便李姐） // getName 变量提升 function getName(){ console.log(5); } function Fun(){ var getName = function(){ console.log(1); } return this; } var getName; // 属性上添加getName Fun.getName = function(){ console.log(2); } // 原型上添加方法 Fun.prototype.getName = function(){ console.log(3); } getName = function(){ console.log(4); } Fun().getName(); getName(); Fun(); new Fun().getName(); new new Fun().getName() 1. Fun().getName()首先执行Fun()时，返回this,这里指向window，相当于 window.getName() , getName最后被 console.log(4) 的函数赋值； 所以输出： 4; 2.getName()相当于执行 window.getName()， 同上。 输出：4； 3.Fun()返回this, 当前环境 window 4.new Fun().getName()这里的执行顺序是 1.先 new Fun() 2.再执行getName() // 相当于执行 var fn = new Fun() fn.getName() 执行new Fun() 实例化的对象 后 ， getName()方法实会去 Fun构造函数中找，没找到然后会去原型 prototype上去找getName。这里原型链有该函数，调用 // 搞清楚 如下 function A(){ this.names = \"ab\" } A.names = \"kk\" A.prototype.names = \"99\" var a = new A() console.log(a.names) // ab console.log(A.names) // kk 5.new new Fun().getName()执行顺序： 1. new Fun() 2. new Fun.prototype.getName() // 相当于执行 var Fn1 = new Fun() var Fn2 = Fn1.getName new Fn2()","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"原型 ","slug":"原型","permalink":"https://www.ding51.cn/tags/原型/"},{"name":"变量提升","slug":"变量提升","permalink":"https://www.ding51.cn/tags/变量提升/"},{"name":"函数提升","slug":"函数提升","permalink":"https://www.ding51.cn/tags/函数提升/"}]},{"title":"回流 重绘","slug":"回流-重绘","date":"2020-07-22T06:29:00.000Z","updated":"2020-07-22T07:55:03.320Z","comments":true,"path":"hui-liu-chong-hui.html","link":"","permalink":"https://www.ding51.cn/hui-liu-chong-hui.html","excerpt":"","text":"一、概念 dom-tree: 浏览器把获取到的HTML代码解析成1个DOM树，DOM树里包含了所有HTML标签，包括display:none隐藏，还有用JS动态添加的元素等。 样式结构体: 浏览器把所有样式(用户定义的CSS和用户代理)解析。 render tree（渲染树）: dom-tree + 样式结构体, render tree中每个NODE都有自己的style，而且render tree不包含隐藏的节点(比如display:none的节点，还有head节点)，因为这些节点不会用于呈现，而且不会影响呈现的，所以就不会包含到 render tree中。 回流：当render tree中的一部分(或全部)因为元素的规模尺寸，布局，隐藏等改变而需要重新构建。这就称为回流(reflow)。每个页面至少需要一次回流，就是在页面第一次加载的时候，这时候是一定会发生回流的 例子： 添加或者删除可见的DOM元素； 元素尺寸改变——边距、填充、边框、宽度和高度 内容变化，比如用户在input框中输入文字 浏览器窗口尺寸改变——resize事件发生时 计算 offsetWidth 和 offsetHeight 属性 设置 style 属性的值 重绘：render tree中的一些元素需要更新属性，而这些属性只是影响元素的外观，风格，而不会影响布局的，比如字体color。则就叫称为重绘。 二、回流重绘区别： 至少会发生一次回流。 回流必将引起重绘，而重绘不一定会引起回流。 三、优化可以发现回流的成本要比重绘的成本高，与构建的render-tree 节点有关系。 浏览器优化浏览器自建一个队列，当回流和重绘达到一定数量或时间时，浏览器再更新。 代码层优化1. 添加dom节点时，创建个模板，一次添加完，不要一个个单独添加。2.分离读写 样式集中修改（浏览器优化机制），集中读取offsetWidth等属性（如果浏览器队列中回流等，每次读取这些属性都会引起回流），建议通过改变class或者csstext属性集中改变样式。 // 会引起四次 回流 div.style.left = '10px'; console.log(div.offsetLeft); div.style.top = '10px'; console.log(div.offsetTop); div.style.width = '20px'; console.log(div.offsetWidth); div.style.height = '20px'; console.log(div.offsetHeight); // 一次回流(前面4个样式的设置，浏览器会优化一次渲染) div.style.left = '10px'; div.style.top = '10px'; div.style.width = '20px'; div.style.height = '20px'; console.log(div.offsetLeft); console.log(div.offsetTop); console.log(div.offsetWidth); console.log(div.offsetHeight); // 推荐使用 class 和 cssText 改变 el.className += \" theclassname\"; el.style.cssText += \"; left: \" + left + \"px; top: \" + top + \"px;\"; 3.缓存布局信息// bad 强制刷新 触发两次重排 div.style.left = div.offsetLeft + 1 + 'px'; div.style.top = div.offsetTop + 1 + 'px'; // good 缓存布局信息 相当于读写分离 var curLeft = div.offsetLeft; var curTop = div.offsetTop; div.style.left = curLeft + 1 + 'px'; div.style.top = curTop + 1 + 'px'; 4.隐藏dom,再修改样式dom.display = 'none' // 修改dom样式，修改完再显示dom dom.display = 'block'","categories":[],"tags":[{"name":"重绘","slug":"重绘","permalink":"https://www.ding51.cn/tags/重绘/"},{"name":"回流","slug":"回流","permalink":"https://www.ding51.cn/tags/回流/"}]},{"title":"http缓存","slug":"http缓存","date":"2020-07-22T03:27:00.000Z","updated":"2020-07-22T03:30:44.805Z","comments":true,"path":"http-huan-cun.html","link":"","permalink":"https://www.ding51.cn/http-huan-cun.html","excerpt":"","text":"一、3种强缓存描述： 不需要发送请求到服务端，直接读取浏览器本地缓存 1. Expires（最低优先级）Expires 的值是一个 HTTP 日期，WEB服务器使用Expires头来告诉Web客户端，会根据系统时间和 Expires 的值进行比较，如果系统时间超过了 Expires 的值，缓存失效。由于和系统时间进行比较，所以当系统时间和服务器时间不一致的时候，会有缓存有效期不准的问题。 Expires 的优先级在三个 Header 属性中是最低的。 2. Cache-Control（中）max-age：单位是秒，缓存时间计算的方式是距离发起的时间的秒数，超过间隔的秒数缓存失效 no-cache：不使用强缓存，需要与服务器验证缓存是否新鲜 no-store：禁止使用缓存（包括协商缓存），每次都向服务器请求最新的资源 private：专用于个人的缓存，中间代理、CDN 等不能缓存此响应 public：响应可以被中间代理、CDN 等缓存 must-revalidate：在缓存过期前可以使用，过期后必须向服务器验证 3. Pragma（最高）Pragma 只有一个属性值，就是 no-cache ，效果和 Cache-Control 中的 no-cache 一致 二、协商缓存当浏览器的强缓存无效，并且在请求头中设置了If-Modified-Since 或者 If-None-Match 的时候，会将这两个属性值到服务端去验证是否命中协商缓存，如果命中了协商缓存，会返回 304 状态，加载浏览器缓存，并且响应头会设置 Last-Modified 或者 ETag 属性。 1. ETag（返回头） If-None-Match（请求头设置）ETag/If-None-Match 的值是一串 hash 码，代表的是一个资源的标识符，当服务端的文件变化的时候，它的 hash码会随之改变，通过请求头中的 If-None-Match 和当前文件的 hash 值进行比较，如果相等则表示命中协商缓存。ETag 又有强弱校验之分，如果 hash 码是以 “W/“ 开头的一串字符串，说明此时协商缓存的校验是弱校验的，只有服务器上的文件差异（根据 ETag 计算方式来决定）达到能够触发 hash 值后缀变化的时候，才会真正地请求资源，否则返回 304 并加载浏览器缓存。 2. Last-Modified（返回头） If-Modified-Since（请求头设置） Last-Modified/If-Modified-Since 的值代表的是文件的最后修改时间，第一次请求服务端会把资源的最后修改时间放到 Last-Modified 响应头中，第二次发起请求的时候，请求头会带上上一次响应头中的 Last-Modified 的时间，并放到 If-Modified-Since 请求头属性中，服务端根据文件最后一次修改时间和 If-Modified-Since 的值进行比较，如果相等，返回 304 ，并加载浏览器缓存。","categories":[{"name":"http","slug":"http","permalink":"https://www.ding51.cn/categories/http/"}],"tags":[{"name":"http缓存","slug":"http缓存","permalink":"https://www.ding51.cn/tags/http缓存/"}]},{"title":"柯里化-偏函数-反柯里化","slug":"柯里化-偏函数-反柯里化","date":"2020-07-21T05:56:00.000Z","updated":"2020-07-21T06:11:20.100Z","comments":true,"path":"ke-li-hua-pian-han-shu-fan-ke-li-hua.html","link":"","permalink":"https://www.ding51.cn/ke-li-hua-pian-han-shu-fan-ke-li-hua.html","excerpt":"","text":"1. 柯里化 描述：柯里化算是特殊的偏函数，把一个多参数函数转换成多个单参数函数，也就是说把一个具有n个参数的函数转换成n个一元函数 特点： 1、闭包，调用柯里化函数（currie）返回另外一个函数（_myFn），通过闭包缓存真正执行运算的函数（fn）和参数（args） 2、 通过返回的函数传递参数，并进行判断，如果参数已经传递够了，就执行函数（fn)并返回结果，如果参数还没传递完，则继续返回函数（_myFn）接收参数 例子： // 正常写法 const add = (a + b) => a+b const resAdd = add(2, 3) // 柯里化 const add = a => b => a+b; const resCurrie = add(2)(3) 2. 偏函数描述： 偏函数又叫局部应用，固定函数的一个或多个参数 特点：偏函数的代码比较简单，就是利用闭包缓存实际的执行方法（fn）和与之的参数（preset），然后返回一个接收剩余参数的方法，方法的实现就是执行fn并返回结果 举例： // 一般写法 // 封装一个ajax方法 function ajax (url, data, callback) { ... } // 调用ajax方法， ajax('http://xxx.com', { a: 'aa' }, function () { // 回调 A }) ajax('http://xxx.com', { b: 'bb' }, function () { // 回调 B }) ajax('http://xxx.com', { y: 'yy' }, function () { // 回调 Y }) // 上面url参数重复填写 // 偏函数 function partial (url) { return function (data, cb) { ajax(url, data, cb) } } // 调用偏函数 const partialAjax = partial('http://lyn.com') // 发送ajax请求 partialAjax({ a: 'aa' }, function () { // 回调 A }) partialAjax({ b: 'bb' }, function () { // 回调 B }) partialAjax({ y: 'yy' }, function () { // 回调 Y }) 3.反柯里化描述： 反柯里化作用和偏函数相反，它的本质是增强一个函数的使用范围，让一个对象可以使用不属于对象自己的方法，就像apply、call、bind（也有偏函数的作用）的作用，而事实上反柯里化就是通过apply、call方法实现的。 举例： Function.prototype.uncurrie = function (obj) { // 参数obj是需要操作的对象 // 这里的this是指obj对象需要借用的方法，比如示例中的Array.prototype.push const fn = this return function (...args) { // 难点，以下代码相当于：fn.call(obj, ...args), 没理解请看下面的 “代码解析” 部分 return Function.prototype.call.apply(fn, [obj, ...args]) } } // 示例，导出Array.prototype.push方法给对象使用 const obj = { a: 'aa' } const push = Array.prototype.push.uncurrie(obj) push('b') push('c') console.log(obj) // {0: \"b\", 1: \"c\", a: \"aa\", length: 2} 参考：https://segmentfault.com/a/1190000022416728","categories":[],"tags":[{"name":"柯里化","slug":"柯里化","permalink":"https://www.ding51.cn/tags/柯里化/"},{"name":"偏函数","slug":"偏函数","permalink":"https://www.ding51.cn/tags/偏函数/"},{"name":"反柯里化","slug":"反柯里化","permalink":"https://www.ding51.cn/tags/反柯里化/"}]},{"title":"ubuntu设置chrome和firefox开机全屏自启","slug":"ubuntu设置chrome和firefox开机全屏自启","date":"2020-06-19T07:36:00.000Z","updated":"2020-06-28T08:04:32.486Z","comments":true,"path":"ubuntu-she-zhi-chrome-he-firefox-kai-ji-quan-ping-zi-qi.html","link":"","permalink":"https://www.ding51.cn/ubuntu-she-zhi-chrome-he-firefox-kai-ji-quan-ping-zi-qi.html","excerpt":"","text":"一. 设置开机自启浏览器注： 此设置基于ubuntu系统1.新建autostar# 查看有没有autostart文件,没有新建 $ mkdir ~/.config/autostart 2.拷贝.desktop 到 autostart# 查找应用位置(如谷歌) sudo find / -name *google-chrome.desktop $ cp /usr/share/applications/firefox.desktop ~/.config/autostart/ 3.文件授权$ chmod +x ~/.config/autostart/firefox.desktop 二. 设置火狐全屏设置1.火狐浏览器自动全屏插件： Auto Fullscreen 注：容易安装成另外一款，特此标注 2.设置浏览器打开不显示上次的历史记录 三. 谷歌全屏，不输密码设置1.每次打开谷歌需要输入密码，免密设置如下 2.谷歌浏览器全屏设置 在command输入最后写入启动打开的地址和全屏参数：http://localhost:8000 --start-fullscreen /usr/bin/google-chrome-stable %U http://localhost:8000 --start-fullscreen 保存即可!","categories":[{"name":"ubuntu浏览器自启设置","slug":"ubuntu浏览器自启设置","permalink":"https://www.ding51.cn/categories/ubuntu浏览器自启设置/"}],"tags":[{"name":"ubuntu ","slug":"ubuntu","permalink":"https://www.ding51.cn/tags/ubuntu/"},{"name":"浏览器自启全屏","slug":"浏览器自启全屏","permalink":"https://www.ding51.cn/tags/浏览器自启全屏/"}]},{"title":"js事件","slug":"js事件流","date":"2019-12-31T08:26:13.000Z","updated":"2020-07-22T07:54:21.830Z","comments":true,"path":"js-shi-jian-liu.html","link":"","permalink":"https://www.ding51.cn/js-shi-jian-liu.html","excerpt":"","text":"js事件概念:HTML中与javascript交互是通过事件驱动来实现的，例如鼠标点击事件、页面的滚动事件onscroll等等,当页面产生一个事件时,该事件会在元素节点与根节点之间的路径传播，路径所经过的节点都会收到该事件，这个传播的过程叫做DOM事件流一. 当页面产生一个事件时经过的三个阶段: 事件捕获阶段document顶部先接收到事件，依次往下传播到事件节点（可以借用addEventListener来模拟事件捕获流） 处于目标阶段 事件冒泡阶段事件开始时由最具体的元素接收，然后逐级向上传播执行流程: 示例代码:说明: addEventListener 第一个参数: 事件名称, 第二个参数: 触发函数, 第三个参数: 布尔 默认false, true表示捕获阶段触发, fals事件冒泡阶段 三：js阻止事件冒泡和默认事件阻止事件冒泡:w3c:e.stopPropagationie:window.event.cancelBubble = true 默认事件：是指目标元素的默认行为比如a标签会跳转链接 form会提交表单w3c:e.preventDefault()ie:window.event.returnValue = false 另外js中的return false也可以阻止默认行为,jq中的return false既可以阻止默认行为也可以阻止冒泡 // 事件绑定的方式, 用return false; 不会阻止默认事件 oBtn.addEventListener('click', function (e) { console.log('btn处于事件冒泡阶段 - 5'); return false; }, false); // 以下代码 return false;可以阻止 oBtn.onclick = function () { return false; }; return false ? 参考文章 四、target 和 currentTargetevent.target指向引起触发事件的元素，而event.currentTarget则是事件绑定监听的元素。 五、宏任务和微任务macrotask（宏任务）：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask） microtask（微任务）：Promise，process.nextTick等","categories":[],"tags":[]},{"title":"节流和防抖","slug":"节流和防抖","date":"2019-12-18T07:51:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"jie-liu-he-fang-dou.html","link":"","permalink":"https://www.ding51.cn/jie-liu-he-fang-dou.html","excerpt":"","text":"函数防抖(debounce)含义: 在事件被触发n秒后再执行回调，如果在这n秒内又被触发，则重新计时。 debounce 使用场景 search搜索联想，用户在不断输入值时，用防抖来节约请求资源。 window触发resize的时候，不断的调整浏览器窗口大小会不断的触发这个事件，用防抖来让其只触发一次 频繁操作点赞和取消点赞，因此需要获取最后一次操作结果并发送给服务器 代码示例: &lt;Input placeholder=\"搜索\" onClick={this.debounce(this.handleSearch, 400)}/> /** * 防抖函数--异步搜索 */ private debounce = (fn: Function, delay: number = 500) => { let timeout = null; let _this = this; return function() { let args = arguments; clearTimeout(timeout); timeout = setTimeout(() => { fn.apply(_this, args); }, delay); }; } 函数节流(throttle)含义: 规定在一个单位时间内，只能触发一次函数。如果这个单位时间内触发多次函数，只有一次生效。 throttle使用场景 鼠标不断点击触发，mousedown(单位时间内只触发一次) 监听滚动事件，比如是否滑到底部自动加载更多，用throttle来判断 代码示例: /** * 节流函数 */ private throttle = (fn: Function, delay: number = 500) => { let _this = this; let isRuning = false; return function () { let args = arguments; if (isRuning) { return; } isRuning = true; setTimeout(() => { isRuning = false; fn.apply(_this, args); }, delay); }; } 总结：函数防抖： 将多次操作合并为一次操作进行。原理是维护一个计时器，规定在delay时间后触发函数，但是在delay时间内再次触发的话，就会取消之前的计时器而重新设置。这样一来，只有最后一次操作能被触发。 函数节流： 使得一定时间内只触发一次函数。原理是通过判断是否有延迟调用函数未执行","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/tags/js/"},{"name":"防抖","slug":"防抖","permalink":"https://www.ding51.cn/tags/防抖/"},{"name":"节流","slug":"节流","permalink":"https://www.ding51.cn/tags/节流/"}]},{"title":"小程序web-view中使用JSSDK,ios安卓踩坑","slug":"web-view-react中JSSDK","date":"2019-12-17T10:41:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"web-view-react-zhong-jssdk.html","link":"","permalink":"https://www.ding51.cn/web-view-react-zhong-jssdk.html","excerpt":"","text":"背景: 在小程序中使用web-view使用react,需要调用相关JSSDK的接口配置, IOS能正常使用,安卓却签名错误invalid signature基础配置按照官方文档来, 这里说明下配置注意事项: 引入微信jssdk，wx.config所用到的工具函数，appid 要使用公众号的APPID，如果APPID使用的是小程序的APPID，config时会报签名无效，要注意config签名参数的大小写 在公众号里面配置,js安全域名配置成web-view的域名 以上配置成功后, 在IOS中使用都能正常使用, 却在安卓机器上使用签名失败invalid signature, 硬是没在网上找到相关解决方案, 很多都是安卓使用正常, IOS使用异常. 煎熬两天综合了其他问题,经过尝试终于通了,记录一下解决方案, 希望帮助遇到同样问题的人 &lt;script type=\"text/javascript\" src=\"https://res.wx.qq.com/open/js/jweixin-1.3.2.js\">&lt;/script> &lt;script> // web-view进入react的第一时间, index.html时记录url if (typeof window.entryUrl === 'undefined' || window.entryUrl === '') { window.entryUrl = location.href.split('#')[0]; } &lt;/script> // 发送给后端签名时 这里就需要区分了!! let isAnd = /(Android)/i.test(navigator.userAgent); //安卓终端 let url = isAnd ? encodeURIComponent(window['entryUrl']) : encodeURIComponent(location.href.split('/?')[0]); 分析: 我这里进入web-view的地址是https://dev.xxx.com?openId=xxx&amp;token=xxxx 然后进入默认路由页面url已经变成https://dev.xxx.com/workbench?appkey=xxx SPA 的router路由机制,在安卓和ios的不同, jssdk url签名的ios只认第一次的路由，我只需要传第一次路由给后端就行","categories":[{"name":"小程序","slug":"小程序","permalink":"https://www.ding51.cn/categories/小程序/"}],"tags":[{"name":"JSSDK","slug":"JSSDK","permalink":"https://www.ding51.cn/tags/JSSDK/"},{"name":"小程序","slug":"小程序","permalink":"https://www.ding51.cn/tags/小程序/"}]},{"title":"git常用的指令","slug":"git常用到的指令","date":"2019-03-27T18:44:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"git-chang-yong-dao-de-zhi-ling.html","link":"","permalink":"https://www.ding51.cn/git-chang-yong-dao-de-zhi-ling.html","excerpt":"","text":"开发时常用的指令1. github配置 ssh key配置cd ~/.ssh 查看是否有id_rsa、id_rsa.pub文件，如果没有需要手动生成。 ssh-keygen -t rsa -C &quot;youremail@example.com&quot; 一路回车.登录github。打开setting-&gt;SSH keys，点击右上角 New SSH key，把生成好的公钥id_rsa.pub放进 key输入框中 2. git常用命令git branch //显示分支一览表，同时确认当前所在的分支git checkout -b aaa //创建名为aaa的分支，并且切换到aaa分支 //创建名为aaa的分支git checkout aaa // 切换到aaa分支git checkout - //切换到上一分支 不小心commit了一个不应该commit的修改，但是还没有push，想回滚那个commit.命令：git log // 查看提交日志 复制下commit_idgit reset --hard commit_id // 回滚 查看更改的记录(后面可以加具体的文件名)git diff 合并本地 分支代码git merge test // test为合并进来的分支 远程仓库查看git remote -v 添加远程仓库git remote add upstream https://github.com/xxxxx/kts-portal.git 重置远程仓库路径git remote set-url upstream https://github.com/xxxxxx/SpringBoot.git 更新远程分支列表git remote update origin --prunegit remote update origin -p 拉取远程某个分支git pull upstream dev","categories":[{"name":"git","slug":"git","permalink":"https://www.ding51.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"https://www.ding51.cn/tags/git/"}]},{"title":"对数组中的某对象排序","slug":"数组中的某对象排序","date":"2019-03-25T15:45:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"shu-zu-zhong-de-mou-dui-xiang-pai-xu.html","link":"","permalink":"https://www.ding51.cn/shu-zu-zhong-de-mou-dui-xiang-pai-xu.html","excerpt":"","text":"利用sort方法排序例子: 对一组数组中的年龄排序. var arr = [ {name:'zopp',age:0}, {name:'gpp',age:18}, {name:'yjj',age:8} ]; // 降序 function compare(name){ return function(a,b){ return a[name] - b[name]; } } // 打乱数组顺序 function disrupt(name){ return function(a,b){ return Math.random() > 0.5 ? -1 : 1; } } console.log(arr.sort(compare('age'))) 结果,: [ {name:&#39;zopp&#39;,age:0}, {name:&#39;yjj&#39;,age:8} {name:&#39;gpp&#39;,age:18}, ];","categories":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/categories/js/"}],"tags":[{"name":"排序","slug":"排序","permalink":"https://www.ding51.cn/tags/排序/"}]},{"title":"node版本升级管理","slug":"ode版本升级管理","date":"2019-03-24T14:38:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"ode-ban-ben-sheng-ji-guan-li.html","link":"","permalink":"https://www.ding51.cn/ode-ban-ben-sheng-ji-guan-li.html","excerpt":"","text":"升级或降级node,网上找了一大堆的资料,看着头皮发麻,只需两行代码的事情 1. sudo npm install -g n // 安装 2. sudo n v9.10.0 // 升级到某个版本 如:v9.10.0 3. sudo n stable // 升级到最稳当版本","categories":[{"name":"node","slug":"node","permalink":"https://www.ding51.cn/categories/node/"}],"tags":[{"name":"node","slug":"node","permalink":"https://www.ding51.cn/tags/node/"}]},{"title":"如何创建发布NPM包?","slug":"创建发布NPM包","date":"2019-01-29T23:59:00.000Z","updated":"2020-05-22T09:00:23.406Z","comments":true,"path":"chuang-jian-fa-bu-npm-bao.html","link":"","permalink":"https://www.ding51.cn/chuang-jian-fa-bu-npm-bao.html","excerpt":"","text":"前言: 平时我们都是使用的别人写好的npm包, npm i xxx ,就直接安装好了使用,本文章介绍的是如何创建自己的封装好的npm包发布。 npm官网创建npm账户npm网站地址：https://www.npmjs.com/ 命令行工具登录npm npm login 验证登录是否成功 npm who am i如果成功会输入你npm个人信息 内镜检测: npm config get registry 如果输出 http://registry.npmjs.org就配置正确, 否则要设置镜像npm config set registry http://registry.npmjs.org 创建npm库npm init接下来就是一长串表单： name：填写你这个包的名字，默认是你这个文件夹的名字。不过这里要着重说一下，最好先去npm上找一下有没有同名的包。最好的测试方式就是，在命令行里面输入npm install 你要取的名字，如果报错，那么很好，npm上没有跟你同名的包，你可以放心大胆地把包发布出去。如果成功下载下来了。。。那么很不幸，改名字吧。。。 version：你这个包的版本，默认是1.0.0 description：其实我也不知道是什么，按回车就好了。。。，这个用一句话描述你的包是干嘛用的，比如我就直接：‘a plugin for express.register routes base on file path’ entry point：入口文件，默认是Index.js，你也可以自己填写你自己的文件名 test command：测试命令，这个直接回车就好了，因为目前还不需要这个。 git repository：这个是git仓库地址，如果你的包是先放到github上或者其他git仓库里，这时候你的文件夹里面会存在一个隐藏的.git目录，npm会读到这个目录作为这一项的默认值。如果没有的话，直接回车继续。 keyword：这个是一个重点，这个关系到有多少人会搜到你的npm包。尽量使用贴切的关键字作为这个包的索引。我这个包嘛，第一是在express下工作的，然后又是一个插件plugin，然后又是一个注册路由route用的，而这个路由又是基于文件目录dir，所以很好就得出我的包的索引关键字。 author：写你的账号或者你的github账号吧 license：这个直接回车，开源文件来着。。。然后它就会问你Are you ok? 直接回车最后生成package.json 同级目录下新建index.js并编写内容 exports.sayHello=function(){ return \"Hello.\"; }; 发布npm包 npm publish发布完成会提示 验证是否发布成功 npm install xxx包 更新版本npm version &lt;update_type&gt; -m &quot;&lt;message&gt;&quot;其中update_type 有三种：patch增加一位补丁号（比如 1.1.1 -&gt; 1.1.2）minor增加一位小版本号（比如 1.1.1 -&gt; 1.2.0）major增加一位大版本号（比如 1.1.1 -&gt; 2.0.0）比如：npm version patch -m &quot;Version %s - v1.0.2&quot;最后提交更新的版本：npm publish 撤销自己发布的版本。这只是一个测试的包，最好当然还是撤销下来npm --force unpublish test_npm 注: 删除要用force强制删除。超过24小时就不能删除了","categories":[{"name":"npm","slug":"npm","permalink":"https://www.ding51.cn/categories/npm/"}],"tags":[{"name":"创建npm包","slug":"创建npm包","permalink":"https://www.ding51.cn/tags/创建npm包/"}]},{"title":"JS如何优雅的写判断语句(二)","slug":"JS如何优雅的写判断语句-二","date":"2019-01-20T20:01:00.000Z","updated":"2020-05-22T09:00:23.404Z","comments":true,"path":"js-ru-he-you-ya-de-xie-pan-duan-yu-ju-er.html","link":"","permalink":"https://www.ding51.cn/js-ru-he-you-ya-de-xie-pan-duan-yu-ju-er.html","excerpt":"","text":"1.多重判断时使用 Array.includes2.更少的嵌套，尽早 return3.使用默认参数和解构4.倾向于遍历对象而不是 Switch 语句5.对 所有/部分 判断使用 Array.every &amp; Array.some 1.多重判断时使用 Array.includes例子: function test(fruit) { if (fruit == 'apple' || fruit == 'strawberry') { console.log('red'); } } 用 Array.includes (Array.includes)重写条件语句 function test(fruit) { const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; if (redFruits.includes(fruit)) { console.log('red'); } } 把条件放入数组,利用includes判断,这样一来，代码看起来更整洁 2.更少的嵌套，尽早 Return例子: function test(fruit, quantity) { const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: fruit 必须有值 if (fruit) { // 条件 2: 必须是red的 if (redFruits.includes(fruit)) { console.log('red'); // 条件 3: quantity大于10 if (quantity > 10) { console.log('big quantity'); } } } else { throw new Error('No fruit!'); } } // 测试结果 test(null); // error: No fruits test('apple'); // print: red test('apple', 20); // print: red, big quantity 当发现无效语句时，尽早Return,少嵌套 function test(fruit, quantity) { const redFruits = ['apple', 'strawberry', 'cherry', 'cranberries']; // 条件 1: 尽早抛出错误 if (!fruit) throw new Error('No fruit!'); // 条件 2: 当水果不是红色时停止继续执行 if (!redFruits.includes(fruit)) return; console.log('red'); // 条件 3: 必须是大质量的 if (quantity > 10) { console.log('big quantity'); } } 3.使用默认参数和解构需要检查 null / undefined的值和指定默认值,例子: // fruit是一个对象{name: 'xx'} , quantity数量设置默认值为 1 function test(fruit, quantity) { // 如果 quantity 参数没有传入，设置默认值为 1 const q = quantity || 1; // 当值存在时打印 fruit 的值 if (fruit &amp;&amp; fruit.name){ console.log(`We have ${quantity} ${fruit.name}!`); }else { console.log('unknown'); } } 使用默认参数和解构 代替 // fruit是一个对象{name: 'xx'} , quantity数量 function test({name} = {}, quantity = 1) { console.log (name || 'unknown'); } 4.倾向于对象遍历而不是if/else Switch语句利用对象代替,可以参考上一篇文章 const fruitColor = { red: ['apple', 'strawberry'], yellow: ['banana', 'pineapple'], purple: ['grape', 'plum'] }; function test(color) { return fruitColor[color] || []; } 5.对 所有/部分 判断使用Array.every &amp; Array.somees6中every,当数组中的数据必须每个满足条件返回true var computers = [ {name:\"Apple\",ram:8}, {name:\"IBM\",ram:4}, {name:\"Acer\",ram:32}, ]; computers.every(computer => computer.ram > 3) // true computers.every(computer => computer.ram > 10) // false some,当数组中只要一条数据满足条件,就返回true var computers = [ {name:\"Apple\",ram:8}, {name:\"IBM\",ram:4}, {name:\"Acer\",ram:32}, ]; computers.some(computer => computer.ram > 8) // true computers.some(computer => computer.ram > 32) // false","categories":[],"tags":[{"name":"js优化","slug":"js优化","permalink":"https://www.ding51.cn/tags/js优化/"}]},{"title":"JS如何优雅的写判断语句(一)","slug":"JS如何优雅的写判断语句","date":"2019-01-20T17:25:00.000Z","updated":"2020-05-22T09:00:23.404Z","comments":true,"path":"js-ru-he-you-ya-de-xie-pan-duan-yu-ju.html","link":"","permalink":"https://www.ding51.cn/js-ru-he-you-ya-de-xie-pan-duan-yu-ju.html","excerpt":"","text":"一.复杂判断优雅写法前言:js代码时经常遇到复杂逻辑判断的情况，通常大家可以用if/else或者switch来实现多个条件判断，但这样会有个问题，随着逻辑复杂度的增加，代码中的if/else/switch会变得越来越臃肿，越来越看不懂。 1.1 一元条件判断一般的写法 if/else 或者 switch/** * @param {number} status 活动状态：1 开团进行 2 开团失败 3 商品售罄 4 开团成功 5 系统取消 */ const onButtonClick = (status) =>{ if (status === 1) { sendLog('processing') jumpTo('IndexPage') } else if (status === 2) { sendLog('fail') jumpTo('FailPage') } else if (status === 3) { sendLog('fail') jumpTo('FailPage') } else if (status === 4) { sendLog('success') jumpTo('SuccessPage') } else if (status === 5) { sendLog('cancel') jumpTo('CancelPage') } else { sendLog('other') jumpTo('Index') } } 优化方法一,将判断条件作为对象的属性名，将处理逻辑作为对象的属性值 const actions = { '1': ['processing', 'IndexPage'], '2': ['fail', 'FailPage'], '3': ['fail', 'FailPage'], '4': ['success', 'SuccessPage'], '5': ['cancel', 'CancelPage'], 'default': ['other', 'Index'], } const onButtonClick = (status) = >{ let action = actions[status] || actions['default'], let logName = action[0], let pageName = action[1]; sendLog(logName); jumpTo(pageName); } 优化方法二,es6里的Map对象 const actions = new Map([ [1, ['processing', 'IndexPage']], [2, ['fail', 'FailPage']], [3, ['fail', 'FailPage']], [4, ['success', 'SuccessPage']], [5, ['cancel', 'CancelPage']], ['default', ['other', 'Index']]]) const onButtonClick = (status) => { let action=actions.get(status)||actions.get('default'); sendLog(action[0]); jumpTo(action[1]); } 1.2 多条件同时判断多条件普通写法 if/elseconst onButtonClick = (status, identity) => { if (identity == 'guest') { if (status == 1) { } else if (status == 2) { } else if (status == 3) { } else if (status == 4) { } else if (status == 5) { } else {} } else if (identity == 'master') { if (status == 1) { } else if (status == 2) { } else if (status == 3) { } else if (status == 4) { } else if (status == 5) { } else {} } } 优化写法一: 利用对象object 或者 map // 利用object对象 字符串拼接 const actions = { 'guest_1': () = >{}, 'guest_2': () = >{}, //.... } const onButtonClick = (identity, status) => { let action = actions[`$ {identity}_${status}`] || actions['default']; action.call(this); } // 利用map对象 字符串拼接 const actions=new Map([ ['guest_1',()=>{}], ['guest_2',()=>{}], ['master_1',()=>{}], ['master_2',()=>{}], ['default',()=>{}], ]); const onButtonClick = (identity, status) => { let action = actions.get(`$ {identity}_${status}`) || actions.get('default'); action.call(this); } 不拼接优化方法二: 用Map对象，以Object对象作为key const actions = new Map([ [{identity: 'guest',status: 1},() = >{}], [{identity: 'guest', status: 2}, () = >{}], ]) const onButtonClick = (identity, status) => { let action = [...actions].filter(([key, value]) =>(key.identity == identity &amp;&amp; key.status == status)); action.forEach(([key, value]) = >value.call(this)); } 注意: 不能直接actions.get({identity: &#39;guest&#39;,status: 1}).call(this)调用 会报错,因为{identity: ‘guest’,status: 1},和map中定义的不是指的同一个对象地址","categories":[],"tags":[{"name":"js优化","slug":"js优化","permalink":"https://www.ding51.cn/tags/js优化/"},{"name":"map对象","slug":"map对象","permalink":"https://www.ding51.cn/tags/map对象/"}]},{"title":"input只能输入数字并限制长度","slug":"input只能输入数字并限制长度","date":"2018-12-26T14:01:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"input-zhi-neng-shu-ru-shu-zi-bing-xian-zhi-chang-du.html","link":"","permalink":"https://www.ding51.cn/input-zhi-neng-shu-ru-shu-zi-bing-xian-zhi-chang-du.html","excerpt":"","text":"随笔记录情景:要求只能输入数字,且限制长度,在谷歌浏览器移除input[number]的上下箭头样式 &lt;input type=&quot;text&quot; maxlength=&quot;5&quot; /&gt; 效果ok，当 &lt;input type=&quot;number&quot; maxlength=&quot;5&quot; /&gt;时maxlength失效，长度可以无限输入 解决参考代码: &lt;style> /*在chrome下移除input[number]的上下箭头*/ input::-webkit-outer-spin-button, input::-webkit-inner-spin-button{ -webkit-appearance: none !important; margin: 0; } /*在firefox下移除input[number]的上下箭头*/ input[type=\"number\"]{-moz-appearance:textfield;} &lt;style> &lt;input type=\"number\" oninput=\"if(value.length>5)value=value.slice(0,5)\">","categories":[{"name":"html5","slug":"html5","permalink":"https://www.ding51.cn/categories/html5/"}],"tags":[{"name":"htm5","slug":"htm5","permalink":"https://www.ding51.cn/tags/htm5/"},{"name":"css","slug":"css","permalink":"https://www.ding51.cn/tags/css/"}]},{"title":"&& || 运算","slug":"运算","date":"2018-12-26T03:39:00.000Z","updated":"2020-08-11T03:42:12.185Z","comments":true,"path":"yun-suan.html","link":"","permalink":"https://www.ding51.cn/yun-suan.html","excerpt":"","text":"1; // true \"0\" // true 0; // false false; // false true; // true \"string\"; // true \"\" // false null // false NaN // false 1.&amp;&amp; Boolean判断，遇到假的值，返回该假值，停止后面判断。 全为真的值，返回最后一个值。 返回第一个遇到的假值。没有假值，返回最后一个真值 // 举例 's' &amp;&amp; '0' &amp;&amp; 0 &amp;&amp; false //结果：0 's','0'为真，计算到 0，值为假。返回该值，停止比较 // 全真 's' &amp;&amp; '0' &amp;&amp; true &amp;&amp; '123' // 123 2.|| Boolean判断，返回第一个真的值，停止后面判断。 全假值，返回最后一个值。 's' || false || '0' || true // 's' 0 || false || null || '0' || false // '0' // 全假 false || 0 || null 3.&amp;&amp;优先级高，先算&amp;&amp; 再 ||''||null||3||4&amp;&amp;5&amp;&amp;0 // 先计算 4&amp;&amp;5&amp;&amp;0 => 0 ''||null||3||0 // 遇到第一个真值3 返回 3 //结果","categories":[{"name":"js基础","slug":"js基础","permalink":"https://www.ding51.cn/categories/js基础/"}],"tags":[{"name":"&&","slug":"","permalink":"https://www.ding51.cn/tags//"},{"name":"||","slug":"","permalink":"https://www.ding51.cn/tags//"}]},{"title":"React生命周期(v16.3 之前版本)","slug":"React新旧生命周期对比-v16-3","date":"2018-12-09T21:14:00.000Z","updated":"2020-05-22T09:00:23.405Z","comments":true,"path":"react-xin-jiu-sheng-ming-zhou-qi-dui-bi-v16-3.html","link":"","permalink":"https://www.ding51.cn/react-xin-jiu-sheng-ming-zhou-qi-dui-bi-v16-3.html","excerpt":"","text":"生命周期对react非常重要,对很多新手来说,搞不懂哪个阶段该做什么事情,迷茫,乱用函数,导致性能下降,死循环. 文章主要记录了react平时常用的生命周期函数,及平时开发遇到的注意事项,自从react v16.3更新后,其生命周期还是发生很大的改变, 这里介绍v16.3之前的版本 React 生命周期主要包括三个阶段：1. 初始化阶段2. 运行中阶段3. 销毁阶段(注:结合图来看文章有助理解) 1. 初始化阶段1-1.设置组件默认属性方法一 挂载组件的时候设置 props(比较常用) var data = [{title: 'Hello'}]; &lt;Hello data={data} /> 方法二 defaultProps在组件内部定义,此方法编译才生效,es6 会报错,使用es7以上(详情) static defaultProps = { age: 18 } 在组件外部属性定义 Greeting.defaultProps = { name: '我是props的默认值！' }; ReactDOM.render( &lt;Greeting />, document.getElementById('example') ); 1-2.组件的初始化状态 stateconstructor(props){ super(props); // 不加super()，导致了this的 Reference Error this.state={}; } super关键字，它指代父类的实例（即父类的this对象）。子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。super(props):传递props作为super()的参数，那就是你需要在构造函数内使用this.props 1-3.componentWillMount因为componentWillMount是在render之前执行，所以在这个方法中setState不会发生重新渲染(re-render),通常情况下，推荐用constructor()方法代替.提示: 很多时候喜欢这里去做一些初始化数据的请求,你会发现数据还没请求到就渲染render()了,当请求到数据后setState再渲染出数据.依然重复渲染. 建议初始化数据都在componentDidMount()中使用,新版本将去掉这个函数. 1-4.render该方法会创建一个虚拟DOM，用来表示组件的输出。对于一个组件来讲，render方法是唯一一个必需的方法。render方法需要满足下面几点： 只能通过 this.props 和 this.state 访问数据（不能修改） 可以返回 null,false 或者任何React组件 只能出现一个顶级组件，不能返回一组元素 不能改变组件的状态 不能修改DOM的输出render方法返回的结果并不是真正的DOM元素，而是一个虚拟的表现，类似于一个DOM tree的结构的对象。 1-5. componentDidMount一般情况在这里做初始化异步数据请求 这个方法会在render()之后立即执行； 这里可以对DOM进行操作，这个函数之后ref变成实际的DOM 2. 组件运行阶段此时组件已经渲染好并且用户可以与它进行交互，比如鼠标点击，手指点按，或者其它的一些事件，导致应用状态的改变，你将会看到下面的方法依次被调用2-1.componentWillReceiveProps组件的 props 属性可以通过父组件来更改，这时，componentWillReceiveProps 将来被调用。可以在这个方法里更新 state,以触发 render 方法重新渲染组件。 componentWillReceiveProps: function(nextProps){ if(nextProps.checked !== undefined){ this.setState({ checked: nextProps.checked }) } } 2-2.shouldComponentUpdate(nextProps, nextState)在接收新的props或state时确定是否发生重新渲染，默认情况返回true，表示会发生重新渲染注意 这个方法在首次渲染时或者forceUpdate()时不会触发; 这个方法如果返回false, 那么props或state发生改变的时候会阻止子组件发生重新渲染; 目前，如果返回false, 那么componentWillUpdate(nextProps, nextState), render(), componentDidUpdate()都不会被触发; 2-3.componentWillUpdate在props或state发生改变或者shouldComponentUpdate(nextProps, nextState)触发后, 在render()之前.千万不要在这个函数中调用this.setState()方法,死循环.结合图表看.2-4.render同上 1-42-5.componentDidUpdate(object prevProps, object prevState)这个方法和 componentDidMount 类似 3.componentWillUnmount组件被销毁时触发。这里我们可以进行一些清理操作，例如清理定时器， 关闭抽屉弹框，取消Redux的订阅事件等等. 总结对比生命周期实例 demo","categories":[{"name":"react","slug":"react","permalink":"https://www.ding51.cn/categories/react/"}],"tags":[{"name":"react生命周期","slug":"react生命周期","permalink":"https://www.ding51.cn/tags/react生命周期/"}]},{"title":"ES6中箭头函数和function的区别","slug":"ES6中箭头函数和function的区别","date":"2018-11-27T13:45:00.000Z","updated":"2020-08-10T07:33:58.055Z","comments":true,"path":"es6-zhong-jian-tou-han-shu-he-function-de-qu-bie.html","link":"","permalink":"https://www.ding51.cn/es6-zhong-jian-tou-han-shu-he-function-de-qu-bie.html","excerpt":"","text":"箭头函数和function的区别总结1.箭头函数与function定义函数的写法//function function fn(a, b){ return a + b; } // 箭头函数 var foo = (a, b)=>{ return a + b }; 2.this的指向1.使用function定义的函数，this的指向随着调用环境的变化而变化的。 //使用function定义的函数 function foo(){ console.log(this); } var obj = { aa: foo }; foo(); //Window obj.aa() //obj { aa: foo } 2.而箭头函数中的this指向是固定不变的，一直指向的是定义它的环境，最近的作用域。 //使用箭头函数定义函数 var foo = () => { console.log(this) }; var obj = { aa:foo }; foo(); //Window obj.aa(); //Window let a = { foo: 1, bar: () => console.log(this.foo) } a.bar() //undefined 原因:箭头函数中的this并不是指向a这个对象。对象a并不能构成一个作用域，所以再往上到达全局作用域，this就指向全局作用域,这里this指向Window。 3.构造函数//使用function方法定义构造函数 function Person(name, age){ this.name = name; this.age = age; } var lenhart = new Person(lenhart, 25); console.log(lenhart); //{name: 'lenhart', age: 25} function是可以定义构造函数的，而箭头函数是不行的。 //尝试使用箭头函数 var Person = (name, age) =>{ this.name = name; this.age = age; }; var lenhart = new Person('lenhart', 25); //Uncaught TypeError: Person is not a constructor 4.变量提升由于js的内存机制，function的级别最高，而用箭头函数定义函数的时候，需要var(let const定义的时候更不必说)关键词，而var所定义的变量不能得到变量提升，故箭头函数一定要定义于调用之前！ foo(); //123 function foo(){ console.log('123'); } arrowFn(); //Uncaught TypeError: arrowFn is not a function var arrowFn = () => { console.log('456'); };","categories":[{"name":"ES6","slug":"ES6","permalink":"https://www.ding51.cn/categories/ES6/"}],"tags":[{"name":"js","slug":"js","permalink":"https://www.ding51.cn/tags/js/"},{"name":"箭头函数this","slug":"箭头函数this","permalink":"https://www.ding51.cn/tags/箭头函数this/"},{"name":"ES6","slug":"ES6","permalink":"https://www.ding51.cn/tags/ES6/"}]},{"title":"Nginx 搭建和配置","slug":"Nginx-搭建和配置","date":"2018-11-21T02:01:00.000Z","updated":"2020-05-22T09:00:23.404Z","comments":true,"path":"nginx-da-jian-he-pei-zhi.html","link":"","permalink":"https://www.ding51.cn/nginx-da-jian-he-pei-zhi.html","excerpt":"","text":"本文章适合新手,其中含有我在实际中遇到的问题解决分享,服务器在搬瓦工租的,不多废话直接上干货 环境： 操作系统：CenOS 6 x86 Nginx 版本：1.14.0 Nginx搭建1.第一步 创建源配置在/etc/yum.repos.d/目录下创建一个源配置文件nginx.repo cd /etc/yum.repos.d/ vim nginx.repo 填写如下内容： [nginx] name=nginx repo baseurl=http://nginx.org/packages/centos/$releasever/$basearch/ gpgcheck=0 enabled=1 保存，则会产生一个/etc/yum.repos.d/nginx.repo文件。 2.第二步 安装直接执行如下指令即可自动安装好Nginx： yum install nginx -y 安装完成，下面直接就可以启动Nginx了： /etc/init.d/nginx start 现在Nginx已经启动了，直接访问服务器就能看到Nginx欢迎页面了的。如果还无法访问:方法一:查看下服务器上端口是否80(阿里云上配下80端口)。方法二:需配置一下Linux防火墙,以此执行如下命令: iptables -I INPUT 5 -i eth0 -p tcp --dport 80 -m state --state NEW,ESTABLISHED -j ACCEPT service iptables save service iptables restart Nginx的相关命令： /etc/init.d/nginx start # 启动Nginx服务 /etc/init.d/nginx stop # 停止Nginx服务 /etc/nginx/nginx.conf # Nginx配置文件位置 chkconfig nginx on #设为开机启动 第三步 前端小优化 nginx开启gzip和缓存配置 (nginx.conf)进入nginx 配置文件vim /etc/nginx/nginx.conf,添加如下配置: # 开启gzip gzip on; # 启用gzip压缩的最小文件，小于设置值的文件将不会压缩 gzip_min_length 1k; # gzip 压缩级别，1-10，数字越大压缩的越好，也越占用CPU时间，后面会有详细说明 gzip_comp_level 2; # 进行压缩的文件类型。javascript有多种形式。其中的值可以在 mime.types 文件中找到。 gzip_types text/plain application/javascript application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png font/ttf font/otf image/svg+xml; # 是否在http header中添加Vary: Accept-Encoding，建议开启 gzip_vary on; # 禁用IE 6 gzip gzip_disable \"MSIE [1-6]\\.\"; # 开启缓存 location ~* ^.+\\.(ico|gif|jpg|jpeg|png)$ { access_log off; expires 30d; } location ~* ^.+\\.(css|js|txt|xml|swf|wav)$ { access_log off; expires 24h; } location ~* ^.+\\.(html|htm)$ { expires 1h; } location ~* ^.+\\.(eot|ttf|otf|woff|svg)$ { access_log off; expires max; } # 格式 # expires 30s; # expires 30m; # expires 2h; # expires 30d; 相关报错问题处理1.vim使用报错:-bash: vim: command not found 使用命令 : yum -y install vim* 2.解决Nginx下使用React-router(其他单页应用vue-router路由)刷新出现404问题server需要重定向到index ,进入配置 vim /etc/nginx/conf.d/default.conf server { listen 80; server_name zlzkj.io; index index.html; root /Volumes/Mac/www/antd-admin/; location / { try_files $uri $uri/ /index.html; // 指向index.html } } 至此，Nginx已经全部配置安装完成,如有问题欢迎留言或联系。","categories":[{"name":"服务器","slug":"服务器","permalink":"https://www.ding51.cn/categories/服务器/"}],"tags":[{"name":"Nginx ","slug":"Nginx","permalink":"https://www.ding51.cn/tags/Nginx/"}]}]}